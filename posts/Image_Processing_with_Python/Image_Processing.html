<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Stephen Barrie">
<meta name="dcterms.date" content="2022-12-20">

<title>Into the Unknown - Image Processing with Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Into the Unknown</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">Stephen Barrie</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Stephen137" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/sjbarrie" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Image Processing with Python</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">TIL</div>
                <div class="quarto-category">Image</div>
                <div class="quarto-category">Data Carpentry</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Stephen Barrie </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 20, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#uses-of-image-processing-in-research" id="toc-uses-of-image-processing-in-research" class="nav-link" data-scroll-target="#uses-of-image-processing-in-research">Uses of Image Processing in Research</a></li>
  <li><a href="#morphometrics" id="toc-morphometrics" class="nav-link" data-scroll-target="#morphometrics">Morphometrics</a></li>
  </ul></li>
  <li><a href="#image-basics" id="toc-image-basics" class="nav-link" data-scroll-target="#image-basics">1. Image Basics</a>
  <ul class="collapse">
  <li><a href="#pixels" id="toc-pixels" class="nav-link" data-scroll-target="#pixels">Pixels</a></li>
  <li><a href="#working-with-pixels" id="toc-working-with-pixels" class="nav-link" data-scroll-target="#working-with-pixels">Working with Pixels</a></li>
  <li><a href="#co-ordinate-system" id="toc-co-ordinate-system" class="nav-link" data-scroll-target="#co-ordinate-system">Co-ordinate system</a></li>
  <li><a href="#changing-pixel-values" id="toc-changing-pixel-values" class="nav-link" data-scroll-target="#changing-pixel-values">Changing pixel values</a></li>
  <li><a href="#more-colours" id="toc-more-colours" class="nav-link" data-scroll-target="#more-colours">More colours</a></li>
  <li><a href="#even-more-colours" id="toc-even-more-colours" class="nav-link" data-scroll-target="#even-more-colours">Even More Colours</a></li>
  <li><a href="#bit-rgb-colour" id="toc-bit-rgb-colour" class="nav-link" data-scroll-target="#bit-rgb-colour">24-bit RGB Colour</a></li>
  <li><a href="#image-formats" id="toc-image-formats" class="nav-link" data-scroll-target="#image-formats">Image formats</a></li>
  <li><a href="#device-independent-bitmap-bmp" id="toc-device-independent-bitmap-bmp" class="nav-link" data-scroll-target="#device-independent-bitmap-bmp">Device-Independent Bitmap (BMP)</a></li>
  <li><a href="#image-compression" id="toc-image-compression" class="nav-link" data-scroll-target="#image-compression">Image compression</a></li>
  <li><a href="#lossless-compression" id="toc-lossless-compression" class="nav-link" data-scroll-target="#lossless-compression">Lossless compression</a></li>
  <li><a href="#lossy-compression" id="toc-lossy-compression" class="nav-link" data-scroll-target="#lossy-compression">Lossy compression</a></li>
  <li><a href="#jpeg" id="toc-jpeg" class="nav-link" data-scroll-target="#jpeg">JPEG</a></li>
  <li><a href="#png" id="toc-png" class="nav-link" data-scroll-target="#png">PNG</a></li>
  <li><a href="#tiff" id="toc-tiff" class="nav-link" data-scroll-target="#tiff">TIFF</a></li>
  <li><a href="#metadata" id="toc-metadata" class="nav-link" data-scroll-target="#metadata">Metadata</a></li>
  <li><a href="#summary-of-image-formats-used-in-this-blog" id="toc-summary-of-image-formats-used-in-this-blog" class="nav-link" data-scroll-target="#summary-of-image-formats-used-in-this-blog">Summary of image formats used in this blog</a></li>
  </ul></li>
  <li><a href="#working-with-skimage" id="toc-working-with-skimage" class="nav-link" data-scroll-target="#working-with-skimage">2. Working with skimage</a>
  <ul class="collapse">
  <li><a href="#reading-displaying-and-saving-images" id="toc-reading-displaying-and-saving-images" class="nav-link" data-scroll-target="#reading-displaying-and-saving-images">Reading, displaying, and saving images</a></li>
  <li><a href="#resizing-an-image" id="toc-resizing-an-image" class="nav-link" data-scroll-target="#resizing-an-image">Resizing an image</a></li>
  <li><a href="#manipulating-pixels" id="toc-manipulating-pixels" class="nav-link" data-scroll-target="#manipulating-pixels">Manipulating pixels</a></li>
  <li><a href="#converting-colour-images-to-grayscale" id="toc-converting-colour-images-to-grayscale" class="nav-link" data-scroll-target="#converting-colour-images-to-grayscale">Converting colour images to grayscale</a></li>
  <li><a href="#plotting-single-channel-images-cmap-vmin-vmax" id="toc-plotting-single-channel-images-cmap-vmin-vmax" class="nav-link" data-scroll-target="#plotting-single-channel-images-cmap-vmin-vmax">Plotting single channel images (cmap, vmin, vmax)</a></li>
  <li><a href="#access-via-slicing" id="toc-access-via-slicing" class="nav-link" data-scroll-target="#access-via-slicing">Access via slicing</a></li>
  </ul></li>
  <li><a href="#drawing-and-bitwise-operations" id="toc-drawing-and-bitwise-operations" class="nav-link" data-scroll-target="#drawing-and-bitwise-operations">3. Drawing and Bitwise Operations</a>
  <ul class="collapse">
  <li><a href="#drawing-on-images" id="toc-drawing-on-images" class="nav-link" data-scroll-target="#drawing-on-images">Drawing on images</a></li>
  <li><a href="#masking" id="toc-masking" class="nav-link" data-scroll-target="#masking">Masking</a></li>
  <li><a href="#other-drawing-operations" id="toc-other-drawing-operations" class="nav-link" data-scroll-target="#other-drawing-operations">Other drawing operations</a></li>
  <li><a href="#image-modification" id="toc-image-modification" class="nav-link" data-scroll-target="#image-modification">Image modification</a></li>
  <li><a href="#masked-monster-truck" id="toc-masked-monster-truck" class="nav-link" data-scroll-target="#masked-monster-truck">Masked monster truck</a></li>
  <li><a href="#masking---iterating-through-a-co-ordinates-file" id="toc-masking---iterating-through-a-co-ordinates-file" class="nav-link" data-scroll-target="#masking---iterating-through-a-co-ordinates-file">Masking - iterating through a co-ordinates file</a></li>
  <li><a href="#masking---using-nested-for-loops" id="toc-masking---using-nested-for-loops" class="nav-link" data-scroll-target="#masking---using-nested-for-loops">Masking - using nested for loops</a></li>
  </ul></li>
  <li><a href="#creating-histograms" id="toc-creating-histograms" class="nav-link" data-scroll-target="#creating-histograms">4. Creating Histograms</a>
  <ul class="collapse">
  <li><a href="#introduction-to-histograms" id="toc-introduction-to-histograms" class="nav-link" data-scroll-target="#introduction-to-histograms">Introduction to Histograms</a></li>
  <li><a href="#grayscale-histograms" id="toc-grayscale-histograms" class="nav-link" data-scroll-target="#grayscale-histograms">Grayscale Histograms</a></li>
  <li><a href="#colour-histograms" id="toc-colour-histograms" class="nav-link" data-scroll-target="#colour-histograms">Colour Histograms</a></li>
  <li><a href="#colour-histogram-with-a-mask" id="toc-colour-histogram-with-a-mask" class="nav-link" data-scroll-target="#colour-histogram-with-a-mask">Colour histogram with a mask</a></li>
  </ul></li>
  <li><a href="#blurring-images" id="toc-blurring-images" class="nav-link" data-scroll-target="#blurring-images">5. Blurring Images</a>
  <ul class="collapse">
  <li><a href="#filters" id="toc-filters" class="nav-link" data-scroll-target="#filters">Filters</a></li>
  <li><a href="#blurring" id="toc-blurring" class="nav-link" data-scroll-target="#blurring">Blurring</a></li>
  <li><a href="#kernels" id="toc-kernels" class="nav-link" data-scroll-target="#kernels">Kernels</a></li>
  <li><a href="#gaussian-blur" id="toc-gaussian-blur" class="nav-link" data-scroll-target="#gaussian-blur">Gaussian blur</a></li>
  <li><a href="#image-edges" id="toc-image-edges" class="nav-link" data-scroll-target="#image-edges">Image edges</a></li>
  <li><a href="#other-methods-of-blurring" id="toc-other-methods-of-blurring" class="nav-link" data-scroll-target="#other-methods-of-blurring">Other methods of blurring</a></li>
  </ul></li>
  <li><a href="#thresholding" id="toc-thresholding" class="nav-link" data-scroll-target="#thresholding">6. Thresholding</a>
  <ul class="collapse">
  <li><a href="#simple-thresholding" id="toc-simple-thresholding" class="nav-link" data-scroll-target="#simple-thresholding">Simple thresholding</a></li>
  <li><a href="#what-makes-a-good-threshold" id="toc-what-makes-a-good-threshold" class="nav-link" data-scroll-target="#what-makes-a-good-threshold">What makes a good threshold?</a></li>
  <li><a href="#automatic-thresholding" id="toc-automatic-thresholding" class="nav-link" data-scroll-target="#automatic-thresholding">Automatic thresholding</a></li>
  <li><a href="#denoising-an-image-before-thresholding" id="toc-denoising-an-image-before-thresholding" class="nav-link" data-scroll-target="#denoising-an-image-before-thresholding">Denoising an image before thresholding</a></li>
  <li><a href="#application-measuring-root-mass" id="toc-application-measuring-root-mass" class="nav-link" data-scroll-target="#application-measuring-root-mass">Application: measuring root mass</a></li>
  <li><a href="#ignoring-more-of-the-images" id="toc-ignoring-more-of-the-images" class="nav-link" data-scroll-target="#ignoring-more-of-the-images">Ignoring more of the images</a></li>
  <li><a href="#thresholding-a-bacteria-colony-image" id="toc-thresholding-a-bacteria-colony-image" class="nav-link" data-scroll-target="#thresholding-a-bacteria-colony-image">Thresholding a bacteria colony image</a></li>
  </ul></li>
  <li><a href="#connected-component-analysis" id="toc-connected-component-analysis" class="nav-link" data-scroll-target="#connected-component-analysis">7. Connected Component Analysis</a>
  <ul class="collapse">
  <li><a href="#pixel-neighborhoods" id="toc-pixel-neighborhoods" class="nav-link" data-scroll-target="#pixel-neighborhoods">Pixel Neighborhoods</a></li>
  <li><a href="#object-counting" id="toc-object-counting" class="nav-link" data-scroll-target="#object-counting">Object counting</a></li>
  <li><a href="#jumps-and-neighborhoods" id="toc-jumps-and-neighborhoods" class="nav-link" data-scroll-target="#jumps-and-neighborhoods">Jumps and neighborhoods</a></li>
  <li><a href="#connected-component-analysis-1" id="toc-connected-component-analysis-1" class="nav-link" data-scroll-target="#connected-component-analysis-1">Connected Component Analysis</a></li>
  <li><a href="#optional-parameters-and-return-values" id="toc-optional-parameters-and-return-values" class="nav-link" data-scroll-target="#optional-parameters-and-return-values">Optional parameters and return values</a></li>
  <li><a href="#how-many-objects-are-in-that-image" id="toc-how-many-objects-are-in-that-image" class="nav-link" data-scroll-target="#how-many-objects-are-in-that-image">How many objects are in that image?</a></li>
  <li><a href="#morphometrics---describe-object-features-with-numbers" id="toc-morphometrics---describe-object-features-with-numbers" class="nav-link" data-scroll-target="#morphometrics---describe-object-features-with-numbers">Morphometrics - Describe object features with numbers</a></li>
  <li><a href="#plot-a-histogram-of-the-object-area-distribution" id="toc-plot-a-histogram-of-the-object-area-distribution" class="nav-link" data-scroll-target="#plot-a-histogram-of-the-object-area-distribution">Plot a histogram of the object area distribution</a></li>
  <li><a href="#filter-objects-by-area" id="toc-filter-objects-by-area" class="nav-link" data-scroll-target="#filter-objects-by-area">Filter objects by area</a></li>
  <li><a href="#remove-small-objects" id="toc-remove-small-objects" class="nav-link" data-scroll-target="#remove-small-objects">Remove small objects</a></li>
  <li><a href="#colour-objects-by-area" id="toc-colour-objects-by-area" class="nav-link" data-scroll-target="#colour-objects-by-area">Colour objects by area</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>As computer systems have become faster and more powerful, and cameras and other imaging systems have become commonplace in many other areas of life, the need has grown for researchers to be able to process and analyse image data. Considering the large volumes of data that can be involved - high-resolution images that take up a lot of disk space/virtual memory, and/or collections of many images that must be processed together - and the time-consuming and error-prone nature of manual processing, it can be advantageous or even necessary for this processing and analysis to be automated as a computer program.</p>
<p>This blog introduces an open source toolkit for processing image data: the Python programming language and the <a href="https://scikit-image.org/">scikit-image (skimage)</a> library. With careful experimental design, Python code can be a powerful instrument in answering many different kinds of questions.</p>
<section id="uses-of-image-processing-in-research" class="level3">
<h3 class="anchored" data-anchor-id="uses-of-image-processing-in-research">Uses of Image Processing in Research</h3>
<p>Automated processing can be used to analyse many different properties of an image, including the distribution and change in colours in the image, the number, size, position, orientation, and shape of objects in the image, and even - when combined with machine learning techniques for object recognition - the type of objects in the image.</p>
<p>Some examples of image processing methods applied in research include:</p>
<ul>
<li><a href="https://iopscience.iop.org/article/10.3847/2041-8213/ab0e85">imaging a Black Hole</a></li>
<li><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3325796/">estimating the population of Emperor Penguins</a></li>
<li><a href="https://www.cell.com/cell/fulltext/S0092-8674(19)31124-9">the global-scale analysis of marine plankton diversity</a></li>
<li><a href="https://www.sciencedirect.com/science/article/abs/pii/S0169260717303383?via%3Dihub">segmentation of liver and vessels from CT images</a></li>
</ul>
<p>This blog aims to provide a thorough grounding in the fundamental concepts and skills of working with image data in Python. Most of the examples used focus on one particular class of image processing technique, morphometrics, but what we will learn can be used to solve a much wider range of problems.</p>
</section>
<section id="morphometrics" class="level3">
<h3 class="anchored" data-anchor-id="morphometrics">Morphometrics</h3>
<p>Morphometrics involves counting the number of objects in an image, analyzing the size of the objects, or analyzing the shape of the objects. For example, we might be interested in automatically counting the number of bacterial colonies growing in a Petri dish.</p>
<p><img src="petri_dish.jpg" width="400" height="400"></p>
<p>We could use image processing to find the colonies, count them, and then highlight their locations on the original image.</p>
<p><img src="colony-mask.png" width="400" height="400"></p>
<p>Note that we can easily manually count the number of bacteria colonies shown in the morphometric example above. So, why should we learn how to write a Python program to do a task we could easily perform with our own eyes? There are at least two reasons to learn how to perform tasks like these with Python and skimage:</p>
<ol type="1">
<li><p>What if there are many more bacteria colonies in the Petri dish? For example, suppose the image looked like this: Manually counting the colonies in that image would present more of a challenge. A Python program using skimage could count the number of colonies more accurately, and much more quickly, than a human could.</p></li>
<li><p>What if we have hundreds, or thousands, of images to consider? Imagine having to manually count colonies on several thousand images like those above. A Python program using skimage could move through all of the images in seconds; how long would a graduate student require to do the task? Which process would be more accurate and repeatable?</p></li>
</ol>
<p>As we can see, the simple image processing / computer vision techniques we will learn during this blog can be very valuable tools for scientific research. As we progress, we will learn image analysis methods useful for many different scientific problems. Let’s get started, by learning some basics about how images are represented and stored digitally.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:<br>

</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Simple Python and skimage (scikit-image) techniques can be used to solve genuine image analysis problems<br>
</li>
<li>Morphometric problems involve the number, shape, and / or size of the objects in an image</li>
</ul>
</div>
</div>
</section>
</section>
<section id="image-basics" class="level2">
<h2 class="anchored" data-anchor-id="image-basics">1. Image Basics</h2>
<p>The images we see on hard copy, view with our electronic devices, or process with our programs are represented and stored in the computer as numeric abstractions, approximations of what we see with our eyes in the real world. Before we begin to learn how to process images with Python programs, we need to spend some time understanding how these abstractions work.</p>
<section id="pixels" class="level3">
<h3 class="anchored" data-anchor-id="pixels">Pixels</h3>
<p>It is important to realise that images are stored as rectangular arrays of hundreds, thousands, or millions of discrete “picture elements,” otherwise known as pixels. Each pixel can be thought of as a single square point of coloured light. For example, consider this image of a maize seedling, with a square area designated by a red box:</p>
<p><img src="maize-seedling-original.jpg" width="600" height="600"></p>
<p>Now, if we zoomed in close enough to see the pixels in the red box, we would see something like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/5f9aef35-9e97-4f16-98c6-420387bb4225-1-c959201d-6ffe-4a0e-9c24-6bb5fbe434d0.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">maize-seedling-enlarged.jpg</figcaption>
</figure>
</div>
<p>Note that each square in the enlarged image area - each pixel - is all one colour, but that each pixel can have a different colour from its neighbours. Viewed from a distance, these pixels seem to blend together to form the image we see.</p>
</section>
<section id="working-with-pixels" class="level3">
<h3 class="anchored" data-anchor-id="working-with-pixels">Working with Pixels</h3>
<p>As noted, in practice, real world images will typically be made up of a vast number of pixels, and each of these pixels will be one of potentially millions of colours. While we will deal with pictures of such complexity shortly, let’s start our exploration with 15 pixels in a 5 X 3 matrix with 2 colours and work our way up to that complexity.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Matrices, arrays, images and pixels
</div>
</div>
<div class="callout-body-container callout-body">
<p>The matrix is mathematical concept - numbers evenly arranged in a rectangle. This can be a two dimensional rectangle, like the shape of the screen you’re looking at now. Or it could be a three dimensional equivalent, a cuboid, or have even more dimensions, but always keeping the evenly spaced arrangement of numbers. In computing, array refers to a structure in the computer’s memory where data is stored in evenly-spaced elements. This is strongly analogous to a matrix. A numpy array is a type of variable (a simpler example of a type is an integer). For our purposes, the distinction between matrices and arrays is not important, we don’t really care how the computer arranges our data in its memory. The important thing is that the computer stores values describing the pixels in images, as arrays. And the terms matrix and array can be used interchangeably.</p>
</div>
</div>
<p>First, the necessary imports:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python libraries for learning and performing image processing</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ipympl</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Import Statements in Python
</div>
</div>
<div class="callout-body-container callout-body">
<p>In Python, the import statement is used to load additional functionality into a program. This is necessary when we want our code to do something more specialised, which cannot easily be achieved with the limited set of basic tools and data structures available in the default Python environment. Additional functionality can be loaded as a single function or object, a module defining several of these, or a library containing many modules. We will encounter several different forms of import statement.</p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># form 1, load whole skimage library</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage  </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># form 2, load skimage.draw module only</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.draw  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># form 3, load only the disk function</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.draw <span class="im">import</span> disk</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># form 4, load all of numpy into an object called np</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np           </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we have our libraries loaded, we will run a Jupyter Magic Command that will ensure our images display in our Jupyter document with pixel information that will help us more efficiently run commands later in the session.</p>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With that taken care of, let’s load our image data from disk using the imread function from the imageio.v3 module and display it using the imshow function from the matplotlib.pyplot module. imageio is a Python library for reading and writing image data. imageio.v3 is specifying that we want to use version 3 of imageio. This version has the benefit of supporting nD (multidimensional) image data natively (think of volumes, movies).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why not use skimage.io.imread()
</div>
</div>
<div class="callout-body-container callout-body">
<p>The skimage library has its own function to read an image, so you might be asking why we don’t use it here. Actually, skimage.io.imread() uses iio.imread() internally when loading an image into Python. It is certainly something you may use as you see fit in your own code. In this lesson, we use the imageio library to read or write (save) images, while skimage is dedicated to performing operations on the images. Using imageio gives us more flexibility, especially when it comes to handling metadata.</p>
</div>
</div>
<div class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage <span class="im">import</span> data, io</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/eight.tif"</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="107">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f29490f2fe0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-5-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>You might be thinking, “That does look vaguely like an eight, and I see two colours but how can that be only 15 pixels”. The display of the eight you see does use a lot more screen pixels to display our eight so large, but that does not mean there is information for all those screen pixels in the file. All those extra pixels are a consequence of our viewer creating additional pixels through interpolation. It could have just displayed it as a tiny image using only 15 screen pixels if the viewer was designed differently.</p>
<p>While many image file formats contain descriptive metadata that can be essential, the bulk of a picture file is just arrays of numeric information that, when interpreted according to a certain rule set, become recognizable as an image to us. Our image of an eight is no exception, and imageio.v3 stored that image data in an array of arrays making a 5 x 3 matrix of 15 pixels. We can demonstrate that by calling on the shape property of our image variable and see the matrix by printing our image variable to the screen.</p>
<div class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(image.shape)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(5, 3)
[[0. 0. 0.]
 [0. 1. 0.]
 [0. 0. 0.]
 [0. 1. 0.]
 [0. 0. 0.]]</code></pre>
</div>
</div>
<p>Thus if we have tools that will allow us to manipulate these arrays of numbers, we can manipulate the image. The numpy library can be particularly useful here, so let’s try that out using numpy array slicing. Notice that the default behavior of the imshow function appended row and column numbers that will be helpful to us as we try to address individual or groups of pixels. First let’s load another copy of our eight, and then make it look like a zero.</p>
<p>To make it look like a zero, we need to change the number underlying the centremost pixel to be 1. With the help of those row and column headers, at this small scale we can determine the centre pixel is in row labeled 2 and column labeled 1. Using array slicing, we can then address and assign a new value to that position.</p>
<p>zero = iio.imread(uri=“Images/eight.tif”) zero[2,1]= 1.0 ““” The following line of code creates a new figure for imshow to use in displaying our output. Without it, plt.imshow() would overwrite our previous image in the cell above ““” fig, ax = plt.subplots() plt.imshow(zero) print(zero)</p>
</section>
<section id="co-ordinate-system" class="level3">
<h3 class="anchored" data-anchor-id="co-ordinate-system">Co-ordinate system</h3>
<p>When we process images, we can access, examine, and / or change the colour of any pixel we wish. To do this, we need some convention on how to access pixels individually; a way to give each one a name, or an address of a sort. The most common manner to do this, and the one we will use in our programs, is to assign a modified Cartesian coordinate system to the image. The coordinate system we usually see in mathematics has a horizontal x-axis and a vertical y-axis, like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/36883774-c9f3-41a6-b94b-02d1d88bf65a-1-7e5dd48d-dc48-4e05-87a0-61bbece9677a.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">cartesian-coordinates.png</figcaption>
</figure>
</div>
<p>The modified coordinate system used for our images will have only positive coordinates, the origin will be in the upper left corner instead of the centre, and y coordinate values will get larger as they go down instead of up, like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/8ff476de-76cd-4755-9359-1a6c35410532-1-f0c8103e-2890-48c9-86bf-b6b49320de10.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">modified-coordinates.png</figcaption>
</figure>
</div>
<p>This is called a left-hand coordinate system. If you hold your left hand in front of your face and point your thumb at the floor, your extended index finger will correspond to the x-axis while your thumb represents the y-axis.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/04e6286f-72e5-4d82-8519-fb1ec29c1f84-1-a3dce119-5072-49bb-8008-c07b06a30c75.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">left-hand-coordinates.png</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The most common mistake made with coordinates is to forget that y coordinates get larger as they go down instead of up as in a normal Cartesian coordinate system.
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consequently, it may be helpful to think in terms of counting down rows (r) for the y-axis and across columns (c) for the x-axis. This can be especially helpful in cases where you need to transpose image viewer data provided in x,y format to y,x format. Thus, we will use cx and ry where appropriate to help bridge these two approaches.</p>
</div>
</div>
</section>
<section id="changing-pixel-values" class="level3">
<h3 class="anchored" data-anchor-id="changing-pixel-values">Changing pixel values</h3>
<p>Let’s load another copy of eight named five, and then change the value of pixels so you have what looks like a 5 instead of an 8. There are many possible solutions, but one method would be . . .</p>
<div class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>five <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/eight.tif"</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>five[<span class="dv">1</span>,<span class="dv">2</span>]<span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>five[<span class="dv">3</span>,<span class="dv">0</span>]<span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(five)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(five)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0. 0. 0.]
 [0. 1. 1.]
 [0. 0. 0.]
 [1. 1. 0.]
 [0. 0. 0.]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-7-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="more-colours" class="level3">
<h3 class="anchored" data-anchor-id="more-colours">More colours</h3>
<p>Up to now, we only had a 2 colour matrix, but we can have more if we use other numbers or fractions. One common way is to use the numbers between 0 and 255 to allow for 256 different colours or 256 different levels of grey. Let’s try that out:</p>
<div class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># make a copy of eight</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>three_colours <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/eight.tif"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># multiply the whole matrix by 128</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>three_colours <span class="op">=</span> three_colours <span class="op">*</span> <span class="dv">128</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># set the middle row (index 2) to the value of 255.,</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># so you end up with the values 0., 128., and 255.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>three_colours[<span class="dv">2</span>,:] <span class="op">=</span> <span class="fl">255.</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.imshow(three_colours)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(three_colours)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0.   0.   0.]
 [  0. 128.   0.]
 [255. 255. 255.]
 [  0. 128.   0.]
 [  0.   0.   0.]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-8-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We now have 3 colours, but are they the three colours you expected? They all appear to be on a continuum of dark purple on the low end and yellow on the high end. This is a consequence of the default colour map (cmap) in this library. You can think of a colour map as an association or mapping of numbers to a specific colour. However, the goal here is not to have one number for every possible colour, but rather to have a continuum of colours that demonstrate relative intensity. In our specific case here for example, 255 or the highest intensity is mapped to yellow, and 0 or the lowest intensity is mapped to a dark purple. The best colour map for your data will vary and there are many options built in, but this default selection was not arbitrary. A lot of science went into making this the default due to its robustness when it comes to how the human mind interprets relative colour values, grey-scale printability, and colour-blind friendliness (You can read more about this default colour map in a Matplotlib tutorial and an explanatory article by the authors). Thus it is a good place to start, and you should change it only with purpose and forethought. For now, let’s see how you can do that using an alternative map you have likely seen before where it will be even easier to see it as a mapped continuum of intensities: greyscale.</p>
<div class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(three_colours,cmap<span class="op">=</span>plt.cm.gray)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="111">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f294bdd79d0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-9-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Above we have exactly the same underying data matrix, but in greyscale. Zero maps to black, 255 maps to white, and 128 maps to medium grey. Here we only have a single channel in the data and utilize a grayscale color map to represent the luminance, or intensity of the data and correspondingly this channel is referred to as the luminance channel.</p>
</section>
<section id="even-more-colours" class="level3">
<h3 class="anchored" data-anchor-id="even-more-colours">Even More Colours</h3>
<p>This is all well and good at this scale, but what happens when we instead have a picture of a natural landscape that contains millions of colours. Having a one to one mapping of number to colour like this would be inefficient and make adjustments and building tools to do so very difficult. Rather than larger numbers, the solution is to have more numbers in more dimensions. Storing the numbers in a multi-dimensional matrix where each colour or property like transparency is associated with its own dimension allows for individual contributions to a pixel to be adjusted independently. This ability to manipulate properties of groups of pixels separately will be key to certain techniques explored in later chapters of this lesson.</p>
<p>To get started let’s see an example of how different dimensions of information combine to produce a set of pixels using a 4 X 4 matrix with 3 dimensions for the colours red, green, and blue. Rather than loading it from a file, we will generate this example using NumPy.</p>
<div class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set the random seed so we all get the same matrix</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>pseudorandomizer <span class="op">=</span> np.random.RandomState(<span class="dv">2021</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a 4 × 4 checkerboard of random colours</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>checkerboard <span class="op">=</span> pseudorandomizer.randint(<span class="dv">0</span>, <span class="dv">255</span>, size<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># restore the default map as you show the image</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>plt.imshow(checkerboard)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># display the arrays</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(checkerboard)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[[116  85  57]
  [128 109  94]
  [214  44  62]
  [219 157  21]]

 [[ 93 152 140]
  [246 198 102]
  [ 70  33 101]
  [  7   1 110]]

 [[225 124 229]
  [154 194 176]
  [227  63  49]
  [144 178  54]]

 [[123 180  93]
  [120   5  49]
  [166 234 142]
  [ 71  85  70]]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-10-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Previously we had one number being mapped to one colour or intensity. <strong>Now</strong> we are combining the effect of 3 numbers to arrive at a single colour value. Let’s see an example of that using the blue square at the end of the second row, which has the index [row, column][1, 3]. Note that in Python indexing starts at zero.</p>
<div class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># extract all the colour information for the blue square</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>upper_right_square <span class="op">=</span> checkerboard[<span class="dv">1</span>, <span class="dv">3</span>, :]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>upper_right_square</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="113">
<pre><code>array([  7,   1, 110])</code></pre>
</div>
</div>
<p>The integers in order represent</p>
<ul>
<li>Red: 7</li>
<li>Green: 1</li>
<li>Blue: 3</li>
</ul>
<p>Looking at theses three values and knowing how they map, can help us understand why it is blue. If we divide each value by 255, which is the maximum, we can determine how much it is contributing relative to its maximum potential. Effectively, the red is at 7/255 or 2.8 percent of its potential, the green is at 1/255 or 0.4 percent, and blue is 110/255 or 43.1 percent of its potential. So when you mix those three intensities of colour, blue is winning by a wide margin, but the red and green still contribute to make it a slightly different shade of blue than 0,0,110 would be on its own.</p>
<p>These colours mapped to dimensions of the matrix may be referred to as channels. It may be helpful to display each of these channels independently, to help us understand what is happening. We can do that by multiplying our image array representation with a 1d matrix that has a one for the channel we want to keep and zeros for the rest.</p>
<div class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># transform array to focus only on the red channel (green and blue channels effectively removed by multiplying by zero)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>red_channel <span class="op">=</span> checkerboard <span class="op">*</span> [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(red_channel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="104">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2949357580&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-12-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># transform array to focus only on the green channel (red and blue channels effectively removed by multiplying by zero)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>green_channel <span class="op">=</span> checkerboard <span class="op">*</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(green_channel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="105">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f29491dae60&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-13-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># transform array to focus only on the blue channel (red and green channels effectively removed by multiplying by zero)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>blue_channel <span class="op">=</span> checkerboard <span class="op">*</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(blue_channel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="106">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2949248700&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-14-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>If we look at the upper [1, 3] square in all three figures, we can see each of those colour contributions in action. Notice that there are several squares in the blue figure that look even more intensely blue than square [1, 3]. When all three channels are combined though, the blue light of those squares is being diluted by the relative strength of red and green being mixed in with them.</p>
</section>
<section id="bit-rgb-colour" class="level3">
<h3 class="anchored" data-anchor-id="bit-rgb-colour">24-bit RGB Colour</h3>
<p>This last colour model we used, known as the RGB (Red, Green, Blue) model, is the most common. As we saw, the RGB model is an additive colour model, which means that the primary colours are mixed together to form other colours. Most frequently, the amount of the primary colour added is represented as an integer in the closed range [0, 255] as seen in the example. Therefore, there are 256 discrete amounts of each primary colour that can be added to produce another colour. The number of discrete amounts of each colour, 256, corresponds to the number of bits used to hold the colour channel value, which is eight (28=256). Since we have three channels with 8 bits for each (8+8+8=24), this is called 24-bit colour depth.</p>
<p>Any particular colour in the RGB model can be expressed by a triplet of integers in [0, 255], representing the red, green, and blue channels, respectively. A larger number in a channel means that more of that primary colour is present.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Suppose that we represent colours as triples (r, g, b), where each of r, g, and b is an integer in [0, 255]. What colours are represented by each of these triples? 1.(255, 0, 0) &nbsp;2.(0, 255, 0) &nbsp;3.(0, 0, 255) &nbsp;4.(255, 255, 255) &nbsp;5.(0, 0, 0) &nbsp;6.(128, 128, 128)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ol type="1">
<li>(255, 0, 0) represents red, because the red channel is maximised, while the other two channels have the minimum values<br>
</li>
<li>(0, 255, 0) represents green<br>
</li>
<li>(0, 0, 255) represents blue<br>
</li>
<li>(255, 255, 255) is a little harder. When we mix the maximum value of all three colour channels, we see the colour white<br>
</li>
<li>(0, 0, 0) represents the absence of all colour, or black<br>
</li>
<li>(128, 128, 128) represents a medium shade of gray. Note that the 24-bit RGB colour model provides at least 254 shades of gray, rather than only fifty</li>
</ol>
</div>
</div>
</div>
<p>Note that the RGB colour model may run contrary to your experience, especially if you have mixed primary colours of paint to create new colours. In the RGB model, the lack of any colour is black, while the maximum amount of each of the primary colours is white. With physical paint, we might start with a white base, and then add differing amounts of other paints to produce a darker shade.</p>
<p>We can look at some further examples of 24-bit RGB colours, in a visual way. The image below shows some colour names, their 24-bit RGB triplet values, and the colour itself:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
We cannot really provide a complete table. To see why, answer this question: How many possible colours can be represented with the 24-bit RGB model?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>There are 24 total bits in an RGB colour of this type, and each bit can be on or off, and so there are <span class="math inline">\(2^{24}\)</span> = 16,777,216 possible colours with our additive, 24-bit RGB colour model.</p>
</div>
</div>
</div>
<p>Although 24-bit colour depth is common, there are other options. We might have 8-bit colour (3 bits for red and green, but only 2 for blue, providing 8 × 8 × 4 = 256 colours) or 16-bit colour (4 bits for red, green, and blue, plus 4 more for transparency, providing 16 × 16 × 16 = 4096 colours), for example. There are colour depths with more than eight bits per channel, but as the human eye can only discern approximately 10 million different colours, these are not often used.</p>
<p>If you are using an older or inexpensive laptop screen or LCD monitor to view images, it may only support 18-bit colour, capable of displaying 64 × 64 × 64 = 262,144 colours. 24-bit colour images will be converted in some manner to 18-bit, and thus the colour quality you see will not match what is actually in the image.</p>
<p>We can combine our coordinate system with the 24-bit RGB colour model to gain a conceptual understanding of the images we will be working with. An image is a rectangular array of pixels, each with its own coordinate. Each pixel in the image is a square point of coloured light, where the colour is specified by a 24-bit RGB triplet. Such an image is an example of <em>raster graphics</em>.</p>
</section>
<section id="image-formats" class="level3">
<h3 class="anchored" data-anchor-id="image-formats">Image formats</h3>
<p>Although the images we will manipulate in our programs are conceptualised as rectangular arrays of RGB triplets, they are not necessarily created, stored, or transmitted in that format. There are several image formats we might encounter, and we should know the basics of at least of few of them. Some formats we might encounter, and their file extensions, are shown in this table:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/cf6fcfe2-e24c-414a-93e0-6393d6df50ae-1-6d142f05-4903-4a20-a3f3-70809ed8ba7e.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">image_formats.JPG</figcaption>
</figure>
</div>
</section>
<section id="device-independent-bitmap-bmp" class="level3">
<h3 class="anchored" data-anchor-id="device-independent-bitmap-bmp">Device-Independent Bitmap (BMP)</h3>
<p>The file format that comes closest to our preceding conceptualisation of images is the Device-Independent Bitmap, or BMP, file format. BMP files store raster graphics images as long sequences of binary-encoded numbers that specify the colour of each pixel in the image. Since computer files are one-dimensional structures, the pixel colours are stored one row at a time. That is, the first row of pixels (those with y-coordinate 0) are stored first, followed by the second row (those with y-coordinate 1), and so on. Depending on how it was created, a BMP image might have 8-bit, 16-bit, or 24-bit colour depth.</p>
<p>24-bit BMP images have a relatively simple file format, can be viewed and loaded across a wide variety of operating systems, and have high quality. However, BMP images are not compressed, resulting in very large file sizes for any useful image resolutions.</p>
<p>The idea of image compression is important to us for two reasons: first, compressed images have smaller file sizes, and are therefore easier to store and transmit; and second, compressed images may not have as much detail as their uncompressed counterparts, and so our programs may not be able to detect some important aspect if we are working with compressed images. Since compression is important to us, we should take a brief detour and discuss the concept.</p>
</section>
<section id="image-compression" class="level3">
<h3 class="anchored" data-anchor-id="image-compression">Image compression</h3>
<p>Before we talk specifically about images, we first need to understand how numbers are stored in a modern digital computer. When we think of a number, we do so using a decimal, or base-10 place-value number system. For example, a number like 659 is 6 × 102 + 5 × 101 + 9 × 100. Each digit in the number is multiplied by a power of 10, based on where it occurs, and there are 10 digits that can occur in each position (0, 1, 2, 3, 4, 5, 6, 7, 8, 9).</p>
<p>In principle, computers could be constructed to represent numbers in exactly the same way. But, the electronic circuits inside a computer are much easier to construct if we restrict the numeric base to only two, instead of 10. (It is easier for circuitry to tell the difference between two voltage levels than it is to differentiate among 10 levels.) So, values in a computer are stored using a binary, or base-2 place-value number system.</p>
<p>In this system, each symbol in a number is called a bit instead of a digit, and there are only two values for each bit (0 and 1). We might imagine a four-bit binary number, 1101. Using the same kind of place-value expansion as we did above for 659, we see that 1101 = 1 × 23 + 1 × 22 + 0 × 21 + 1 × 20, which if we do the math is 8 + 4 + 0 + 1, or 13 in decimal.</p>
<p>Internally, computers have a minimum number of bits that they work with at a given time: eight. A group of eight bits is called a byte. The amount of memory (RAM) and drive space our computers have is quantified by terms like Megabytes (MB), Gigabytes (GB), and Terabytes (TB). The following table provides more formal definitions for these terms:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/6771a503-2ae4-499a-8e3d-9c96cf5db483-1-38cf3051-95bf-4142-b0e9-0fba19a7f540.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">bits.JPG</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Imagine that we have a fairly large, but very boring image: a 5,000 × 5,000 pixel image composed of nothing but white pixels. If we used an uncompressed image format such as BMP, with the 24-bit RGB colour model, how much storage would be required for the file?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In such an image, there are 5,000 × 5,000 = 25,000,000 pixels, and 24 bits for each pixel, leading to 25,000,000 × 24 = 600,000,000 bits, or 75,000,000 bytes (71.5MB). That is quite a lot of space for a very uninteresting image!</p>
</div>
</div>
</div>
<p>Since image files can be very large, various compression schemes exist for saving (approximately) the same information while using less space. These compression techniques can be categorised as lossless or lossy.</p>
</section>
<section id="lossless-compression" class="level3">
<h3 class="anchored" data-anchor-id="lossless-compression">Lossless compression</h3>
<p>In lossless image compression, we apply some algorithm (i.e., a computerised procedure) to the image, resulting in a file that is significantly smaller than the uncompressed BMP file equivalent would be. Then, when we wish to load and view or process the image, our program reads the compressed file, and reverses the compression process, resulting in an image that is identical to the original. Nothing is lost in the process – hence the term “lossless.”</p>
<p>The general idea of lossless compression is to somehow detect long patterns of bytes in a file that are repeated over and over, and then assign a smaller bit pattern to represent the longer sample. Then, the compressed file is made up of the smaller patterns, rather than the larger ones, thus reducing the number of bytes required to save the file. The compressed file also contains a table of the substituted patterns and the originals, so when the file is decompressed it can be made identical to the original before compression.</p>
<p>To provide you with a concrete example, consider the 71.5 MB white BMP image discussed above. When put through the zip compression utility on Microsoft Windows, the resulting .zip file is only 72 KB in size! That is, the .zip version of the image is three orders of magnitude smaller than the original, and it can be decompressed into a file that is byte-for-byte the same as the original. Since the original is so repetitious - simply the same colour triplet repeated 25,000,000 times - the compression algorithm can dramatically reduce the size of the file.</p>
<p>If you work with <strong>.zip</strong> or <strong>.gz</strong> archives, you are dealing with lossless compression.</p>
</section>
<section id="lossy-compression" class="level3">
<h3 class="anchored" data-anchor-id="lossy-compression">Lossy compression</h3>
<p>Lossy compression takes the original image and discards some of the detail in it, resulting in a smaller file format. The goal is to only throw away detail that someone viewing the image would not notice. Many lossy compression schemes have adjustable levels of compression, so that the image creator can choose the amount of detail that is lost. The more detail that is sacrificed, the smaller the image files will be - but of course, the detail and richness of the image will be lower as well.</p>
<p>This is probably fine for images that are shown on Web pages or printed off on 4 × 6 photo paper, but may or may not be fine for scientific work. You will have to decide whether the loss of image quality and detail are important to your work, versus the space savings afforded by a lossy compression format.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
It is important to understand that once an image is saved in a lossy compression format, the lost detail is just that - lost.
</div>
</div>
<div class="callout-body-container callout-body">
<p>Unlike lossless formats, given an image saved in a lossy format, there is no way to reconstruct the original image in a byte-by-byte manner.</p>
</div>
</div>
</section>
<section id="jpeg" class="level3">
<h3 class="anchored" data-anchor-id="jpeg">JPEG</h3>
<p>JPEG images are perhaps the most commonly encountered digital images today. JPEG uses lossy compression, and the degree of compression can be tuned to your liking. It supports 24-bit colour depth, and since the format is so widely used, JPEG images can be viewed and manipulated easily on all computing platforms.</p>
<p>Let us see the effects of image compression on image size with actual images. The following script creates a square white image 5000 X 5000 pixels, and then saves it as a BMP and as a JPEG image.</p>
<div class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">5000</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> np.zeros((dim, dim, <span class="dv">3</span>), dtype<span class="op">=</span><span class="st">"uint8"</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>img.fill(<span class="dv">255</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/ws.bmp"</span>, image<span class="op">=</span>img)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/ws.jpg"</span>, image<span class="op">=</span>img)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/96c9ba11-bbcb-4fe9-b02d-efa900f37ca7-1-d73d6acd-ab2c-43c0-97be-0a5e3a5fa228.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">download.jpg</figcaption>
</figure>
</div>
<p>The BMP file, ws.bmp, is 75,000,054 bytes, which matches our prediction very nicely. The JPEG file, ws.jpg, is 392,503 bytes, two orders of magnitude smaller than the bitmap version.</p>
<p>Let us see a hands-on example of lossless versus lossy compression. Once again, open a terminal and navigate to the data/ directory. The two output images, ws.bmp and ws.jpg, should still be in the directory, along with another image, tree.jpg.</p>
<p>We can apply lossless compression to any file by using the zip command. Recall that the ws.bmp file contains 75,000,054 bytes. Apply lossless compression to this image by executing the following command:</p>
<pre><code>zip ws.zip ws.bmp. </code></pre>
<p>This command tells the computer to create a new compressed file, ws.zip, from the original bitmap image. Execute a similar command on the tree JPEG file:</p>
<pre><code>zip tree.zip tree.jpg.</code></pre>
<p>Having created the compressed file, use the ls -al command to display the contents of the directory.</p>
<ul>
<li>How big are the compressed files?</li>
<li>How do those compare to the size of ws.bmp and tree.jpg?</li>
<li>What can you conclude from the relative sizes?</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/d66a62f4-78d1-4d3c-86de-54342e1dc4b0-1-143d18e0-6127-4392-bc6c-8093ac86ca67.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">zipped.JPG</figcaption>
</figure>
</div>
<p>The tree.jpg has not reduced in size as this was already in a compressed format. However the regularity of the bitmap image (remember, it is a 5,000 x 5,000 pixel image containing only white pixels) allows the lossless compression scheme to compress the ws.bmp file quite effectivelym reducing the size from 7,500,054 bytes (71.52Mb) to 72,998 bytes (71.29kb).</p>
<p>Here is an example showing how JPEG compression might impact image quality. Consider this image of several maize seedlings (scaled down here from 11,339 × 11,336 pixels in order to fit the display):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/ff107bad-b9f3-4ed8-a11e-8451c977cf6f-1-843057c7-37c0-4c0d-83a8-243c46aa260b.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">quality-original.jpg</figcaption>
</figure>
</div>
<p>Now, let us zoom in and look at a small section of the label in the original, first in the uncompressed format:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/14161aeb-bf99-4c9b-aa0c-c67f9169ac8b-1-c5321667-a2bd-4c6a-84c6-5b7e52c03ff2.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">quality-tif.jpg</figcaption>
</figure>
</div>
<p>Here is the same area of the image, but in JPEG format. We used a fairly aggressive compression parameter to make the JPEG, in order to illustrate the problems you might encounter with the format.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/768dd453-0c18-4856-8fa1-4c3e085e8f3f-1-40c67fd8-8215-4a8d-a3d4-181155b396b0.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">quality-jpg.jpg</figcaption>
</figure>
</div>
<p>The JPEG image is of clearly inferior quality. It has less colour variation and noticeable pixelation. Quality differences become even more marked when one examines the colour histograms for each image. A histogram shows how often each colour value appears in an image. The histograms for the uncompressed (left) and compressed (right) images are shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/0f7de0b2-93b5-4161-b28e-5b5426d4dd83-1-5bfc3ea9-ce82-4d7d-99cc-b8f38779a9e9.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">quality-histogram.jpg</figcaption>
</figure>
</div>
<p>We learn how to make histograms such as these later on in the workshop. The differences in the colour histograms are even more apparent than in the images themselves; clearly the colours in the JPEG image are different from the uncompressed version.</p>
<p>If the quality settings for your JPEG images are high (and the compression rate therefore relatively low), the images may be of sufficient quality for your work. It all depends on how much quality you need, and what restrictions you have on image storage space. Another consideration may be where the images are stored. For example,if your images are stored in the cloud and therefore must be downloaded to your system before you use them, you may wish to use a compressed image format to speed up file transfer time.</p>
</section>
<section id="png" class="level3">
<h3 class="anchored" data-anchor-id="png">PNG</h3>
<p>PNG images are well suited for storing diagrams. It uses a lossless compression and is hence often used in web applications for non-photographic images. The format is able to store RGB and plain luminance (single channel, without an associated color) data, among others. Image data is stored row-wise and then, per row, a simple filter, like taking the difference of adjacent pixels, can be applied to increase the compressability of the data. The filtered data is then compressed in the next step and written out to the disk.</p>
</section>
<section id="tiff" class="level3">
<h3 class="anchored" data-anchor-id="tiff">TIFF</h3>
<p>TIFF images are popular with publishers, graphics designers, and photographers. TIFF images can be uncompressed, or compressed using either lossless or lossy compression schemes, depending on the settings used, and so TIFF images seem to have the benefits of both the BMP and JPEG formats. The main disadvantage of TIFF images (other than the size of images in the uncompressed version of the format) is that they are not universally readable by image viewing and manipulation software.</p>
</section>
<section id="metadata" class="level3">
<h3 class="anchored" data-anchor-id="metadata">Metadata</h3>
<p>JPEG and TIFF images support the inclusion of metadata in images. Metadata is textual information that is contained within an image file. Metadata holds information about the image itself, such as when the image was captured, where it was captured, what type of camera was used and with what settings, etc. We normally don’t see this metadata when we view an image, but we can view it independently if we wish to (see Accessing Metadata, below). The important thing to be aware of at this stage is that you cannot rely on the metadata of an image being fully preserved when you use software to process that image.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The image reader/writer library that we use throughout this blog, imageio.v3, includes metadata when saving new images but may fail to keep certain metadata fields.
</div>
</div>
<div class="callout-body-container callout-body">
<p>If metadata is important to you, take precautions to always preserve the original files.</p>
</div>
</div>
<p>Metadata is served independently from pixel data. imageio.v3 provides a way to display or explore the metadata associated with an image:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read metadata</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> iio.immeta(uri<span class="op">=</span><span class="st">'Images/eight.tif'</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display the format-specific metadata</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>metadata</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>{'is_fluoview': False,
 'is_nih': False,
 'is_micromanager': False,
 'is_ome': False,
 'is_lsm': False,
 'is_reduced': False,
 'is_shaped': True,
 'is_stk': False,
 'is_tiled': False,
 'is_mdgel': False,
 'compression': &lt;COMPRESSION.NONE: 1&gt;,
 'predictor': 1,
 'is_mediacy': False,
 'description': '{"shape": [5, 3]}',
 'description1': '',
 'is_imagej': False,
 'software': 'tifffile.py',
 'resolution_unit': 1,
 'resolution': (1.0, 1.0, 'NONE')}</code></pre>
</div>
</div>
<p>Other software exists that can help you handle metadata, such as <a href="https://imagej.net/software/fiji/">Fiji</a> and <a href="https://imagemagick.org/index.php">ImageMagick</a>. You may want to explore these options if you need to work with the metadata of your images.</p>
</section>
<section id="summary-of-image-formats-used-in-this-blog" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-image-formats-used-in-this-blog">Summary of image formats used in this blog</h3>
<p>The following table summarises the characteristics of the BMP, JPEG, and TIFF image formats:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/7c4271d2-95a1-403e-8122-c3887be03bda-1-18b688af-fce8-4570-b3b9-5069bd5a2b4e.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">formats.JPG</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>digital images are represented as rectangular arrays of square pixels.</li>
<li>digital images use a left-hand coordinate system, with the origin in the upper left corner, the x-axis running to the right, and the y-axis running down. Some learners may prefer to think in terms of counting down rows for the y-axis and across columns for the x-axis. Thus, we will make an effort to allow for both approaches in our lesson presentation.</li>
<li>most frequently, digital images use an additive RGB model, with eight bits for the red, green, and blue channels.</li>
<li>skimage images are stored as multi-dimensional NumPy arrays.</li>
<li>in skimage images, the red channel is specified first, then the green, then the blue, i.e., RGB.</li>
<li>lossless compression retains all the details in an image, but lossy compression results in loss of some of the original image detail.</li>
<li>BMP images are uncompressed, meaning they have high quality but also that their file sizes are large.</li>
<li>JPEG images use lossy compression, meaning that their file sizes are smaller, but image quality may suffer.</li>
<li>TIFF images can be uncompressed or compressed with lossy or lossless compression.</li>
<li>depending on the camera or sensor, various useful pieces of information may be stored in an image file, in the image metadata.</li>
</ul>
</div>
</div>
</section>
</section>
<section id="working-with-skimage" class="level2">
<h2 class="anchored" data-anchor-id="working-with-skimage">2. Working with skimage</h2>
<p>In the previous section we covered much of how images are represented in computer software. In this section we will learn some more methods for accessing and changing digital images.</p>
<section id="reading-displaying-and-saving-images" class="level3">
<h3 class="anchored" data-anchor-id="reading-displaying-and-saving-images">Reading, displaying, and saving images</h3>
<p>Imageio provides intuitive functions for reading and writing (saving) images. All of the popular image formats, such as BMP, PNG, JPEG, and TIFF are supported, along with several more esoteric formats. Check the <a href="https://imageio.readthedocs.io/en/stable/formats/index.html">Supported Formats docs</a> for a list of all formats. Matplotlib provides a large collection of plotting utilities.</p>
<p>Let us examine a simple Python program to load, display, and save an image to a different format. First, we import the v3 module of imageio (imageio.v3) as iio so we can read and write images. Then, we use the iio.imread() function to read a JPEG image entitled chair.jpg. Here are the first few lines:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python program to open, display, and save an image.</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># read image</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">'Images/chair.jpg'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we will do something with the image. Once we have the image in the program, we first call plt.subplots() so that we will have a fresh figure with a set of axis independent from our previous calls. Next we call plt.imshow() in order to display the image:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f0839e0da80&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-18-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Now, we will save the image in another format:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># save a new version in .tif format</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/chair.tif"</span>, image<span class="op">=</span>image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The final statement in the program, iio.imwrite(uri=“data/chair.tif”, image=image), writes the image to a file named chair.tif in our Images/ directory. The imwrite() function automatically determines the type of the file, based on the file extension we provide. In this case, the .tif extension causes the image to be saved as a TIFF.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The iio.imwrite() function automatically uses the file type we specify in the file name parameter’s extension.
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that this is not always the case. For example, if we are editing a document in Microsoft Word, and we save the document as paper.pdf instead of paper.docx, the file is not saved as a PDF document.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>When we call functions in Python, there are two ways we can specify the necessary arguments. We can specify the arguments positionally, i.e., in the order the parameters appear in the function definition, or we can use named arguments.</p>
<p>For example, the iio.imwrite() function definition specifies two parameters, the resource to save the image to (e.g., a file name, an http address) and the image to write to disk. So, we could save the chair image in the sample code above using positional arguments like this:</p>
<pre><code>iio.imwrite("data/chair.tif", image)</code></pre>
<p>Since the function expects the first argument to be the file name, there is no confusion about what “data/chair.jpg” means. The same goes for the second argument.</p>
<p>The style we will use in this workshop is to name each argument, like this:</p>
<pre><code>iio.imwrite(uri="data/chair.tif", image=image)</code></pre>
<p>This style will make it easier for you to learn how to use the variety of functions we will cover in this blog.</p>
</div>
</div>
</section>
<section id="resizing-an-image" class="level3">
<h3 class="anchored" data-anchor-id="resizing-an-image">Resizing an image</h3>
<p>Add import skimage.transform and import skimage.util to your list of imports. Using the chair.jpg image located in the data folder, write a Python script to read your image into a variable named image. Then, resize the image to 10 percent of its current size using these lines of code:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.transform, skimage.util</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">'Images/chair.jpg'</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"># resize to 10% of original size</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>new_shape <span class="op">=</span> (image.shape[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">10</span>, image.shape[<span class="dv">1</span>] <span class="op">//</span> <span class="dv">10</span>, image.shape[<span class="dv">2</span>])</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co"># image file stored as whole numbers for space efficiency</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>small <span class="op">=</span> skimage.transform.resize(image<span class="op">=</span>image, output_shape<span class="op">=</span>new_shape)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># converts image back to whole numbers before saving to disk</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>small <span class="op">=</span> skimage.util.img_as_ubyte(small)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As it is used here, the parameters to the <strong><em>skimage.transform.resize()</em></strong> function are the image to transform, image, the dimensions we want the new image to have, new_shape.</p>
<p>Note that the pixel values in the new image are an approximation of the original values and should not be confused with actual, observed data. This is because skimage interpolates the pixel values when reducing or increasing the size of an image. skimage.transform.resize has a number of optional parameters that allow the user to control this interpolation. You can find more details in the <a href="https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.resize">scikit-image documentation</a>.</p>
<p>Image files on disk are normally stored as whole numbers for space efficiency, but transformations and other math operations often result in conversion to floating point numbers. Using the <strong><em>skimage.util.img_as_ubyte()</em></strong> method converts it back to whole numbers before we save it back to disk. If we don’t convert it before saving, iio.imwrite() may not recognise it as image data.</p>
<p>Next, write the resized image out to a new file named resized.jpg in your data directory. Finally, use plt.imshow() with each of your image variables to display both images in your notebook. Don’t forget to use fig, ax = plt.subplots() so you don’t overwrite the first image with the second. Images may appear the same size in jupyter, but you can see the size difference by comparing the scales for each. You can also see the differnce in file storage size on disk by hovering your mouse cursor over the original and the new file in the jupyter file browser, using ls -l in your shell, or the OS file browser if it is configured to show file sizes.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># write the resized image out to a new file named resized.jpg</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/resized.jpg"</span>, image<span class="op">=</span>small)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot original image</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Original image"</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co"># plot resized image</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>plt.imshow(small)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Reduced to 10</span><span class="sc">% o</span><span class="st">f size of original image"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>Text(0.5, 1.0, 'Reduced to 10% of size of original image')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-21-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-21-output-3.png" class="img-fluid"></p>
</div>
</div>
<p>We can see from the above that our reduction to 10% of the original size appears to have been successsful. The axes of the reduced image are 0-300 and 0-400 as against 0-3000 and 0-4000.</p>
<p>The script has: - resized the data/chair.jpg image by a factor of 10 in both dimensions - saved the result to the data/resized.jpg file, and - displays original and resized for comparision</p>
</section>
<section id="manipulating-pixels" class="level3">
<h3 class="anchored" data-anchor-id="manipulating-pixels">Manipulating pixels</h3>
<section id="retaining-only-high-intensity-pixels" class="level4">
<h4 class="anchored" data-anchor-id="retaining-only-high-intensity-pixels">Retaining only high intensity pixels</h4>
<p>In section 1, we individually manipulated the colours of pixels by changing the numbers stored in the image’s NumPy array. Let’s apply the principles learned there along with some new principles to a real world example. Suppose we are interested in this maize root cluster image.</p>
<p><img src="Images/maize_cluster.jpg" width="600" height="600"></p>
<p>We want to be able to focus our program’s attention on the roots themselves, while ignoring the black background.</p>
<p>Since the image is stored as an array of numbers, we can simply look through the array for pixel colour values that are less than some threshold value. This process is called <strong><em>thresholding</em></strong>, and we will see more powerful methods to perform the thresholding task in the Thresholding section.</p>
<p>Here, though, we will look at a simple and elegant NumPy method for thresholding. Let us develop a program that keeps only the pixel colour values in an image that have value greater than or equal to 128. This will keep the pixels that are brighter than half of “full brightness”, i.e., pixels that do not belong to the black background. We will start by reading the image and displaying it.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"># read input image</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/maize_cluster.jpg"</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co"># display original image</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f4d204fe320&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-22-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Now we can threshold the image and display the result:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># keep only high-intensity pixels</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>image[image <span class="op">&lt;</span> <span class="dv">128</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display modified image</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ValueError: assignment destination is read-only</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Check if the array is writeable with <em>image.flags</em><br>

</div>
</div>
<div class="callout-body-container callout-body">
<p>If WRITEABLE is false, change it with <em>img.setflags(write=1)</em><br>
If after doing this you receive ValueError: cannot set WRITEABLE flag to True of this array, then as a workaround create a copy of the image using <em>image_copy = image.copy()</em></p>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>image.flags</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : False
  ALIGNED : True
  WRITEBACKIFCOPY : False</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>image.setflags(write<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ValueError: cannot set WRITEABLE flag to True of this array</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># workaround to address the read-only issues</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>image_copy <span class="op">=</span> image.copy()</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co"># keep only high-intensity pixels, by setting all low-intensity pixels &lt; 128 to zero</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>image_copy[image_copy <span class="op">&lt;</span> <span class="dv">128</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display modified image</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(image_copy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f4d11f9c4c0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-26-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The result is an image in which the extraneous background detail has been removed.</p>
</section>
</section>
<section id="converting-colour-images-to-grayscale" class="level3">
<h3 class="anchored" data-anchor-id="converting-colour-images-to-grayscale">Converting colour images to grayscale</h3>
<p>It is often easier to work with grayscale images, which have a single channel, instead of colour images, which have three channels. Skimage offers the function <strong><em>skimage.color.rgb2gray()</em></strong> to achieve this. This function adds up the three colour channels in a way that matches human colour perception, see the <a href="https://scikit-image.org/docs/dev/api/skimage.color.html#skimage.color.rgb2gray">skimage documentation</a> for details. It returns a grayscale image with floating point values in the range from 0 to 1. We can use the function <em>skimage.util.img_as_ubyte()</em> in order to convert it back to the original data type and the data range back 0 to 255. Note that it is often better to use image values represented by floating point values, because <strong>using floating point numbers is numerically more stable</strong>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
skimage contains many modules and functions that include the US English spelling, color.
</div>
</div>
<div class="callout-body-container callout-body">
<p>The exact spelling matters here, e.g.&nbsp;you will encounter an error if you try to run skimage.colour.rgb2gray(). To account for this, we will use the US English spelling, color, in example Python code throughout this blog. We will adopt a similar approach with “centre” and center.</p>
</div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"># read input image</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/chair.jpg"</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display original image</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Original image"</span>)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="co"># convert to grayscale and display</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(gray_image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale image"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>Text(0.5, 1.0, 'Grayscale image')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-27-output-2.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-27-output-3.png" class="img-fluid"></p>
</div>
</div>
<p>We also load colour images as grayscale <strong>directly</strong> by passing the argument <strong><em>mode=“L” </em></strong> to iio.imread():</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"># read input image, based on filename parameter</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/chair.jpg"</span>, mode<span class="op">=</span><span class="st">"L"</span>)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display grayscale image</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale image"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>Text(0.5, 1.0, 'Grayscale image')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-28-output-2.png" class="img-fluid"></p>
</div>
</div>
<section id="retaining-only-low-intensity-pixels" class="level4">
<h4 class="anchored" data-anchor-id="retaining-only-low-intensity-pixels">Retaining only low intensity pixels</h4>
<p>A little earlier, we showed how we could use Python and skimage to turn on only the high intensity pixels from an image, while turning all the low intensity pixels off. Now, let’s practice doing the opposite - keeping all the low intensity pixels while changing the high intensity ones, by turning all of the white pixels in the image to a light gray colour, say with the intensity of each formerly white pixel set to 0.75:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read input image, based on filename parameter</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>sudoku <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/sudoku.png"</span>, mode<span class="op">=</span><span class="st">"L"</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display grayscale image</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(sudoku, cmap<span class="op">=</span><span class="st">"gray"</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale image"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>Text(0.5, 1.0, 'Grayscale image')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-29-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clip all high intensity pixels &gt; 0.75 to 0.75</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>sudoku[sudoku <span class="op">&gt;</span> <span class="fl">0.75</span>] <span class="op">=</span> <span class="fl">0.75</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display modified image</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(sudoku, cmap<span class="op">=</span><span class="st">"gray"</span>, vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><img src="Images/sudoku-gray.png" width="420" height="420"></p>
</section>
</section>
<section id="plotting-single-channel-images-cmap-vmin-vmax" class="level3">
<h3 class="anchored" data-anchor-id="plotting-single-channel-images-cmap-vmin-vmax">Plotting single channel images (cmap, vmin, vmax)</h3>
<p>Compared to a colour image, a grayscale image contains only a single intensity value per pixel. When we plot such an image with plt.imshow, matplotlib uses a colour map, to assign each intensity value a colour. The default colour map is called “viridis” and maps low values to purple and high values to yellow. We can instruct matplotlib to map low values to black and high values to white instead, by calling plt.imshow with cmap=“gray”. The documentation contains an overview of pre-defined colour maps.</p>
<p>Furthermore, matplotlib determines the minimum and maximum values of the colour map dynamically from the image, by default. That means, that in an image, where the minimum is 0.25 and the maximum is 0.75, those values will be mapped to black and white respectively (and not dark gray and light gray as you might expect). If there are defined minimum and maximum vales, you can specify them via vmin and vmax to get the desired output. If you forget about this, it can lead to unexpected results.</p>
</section>
<section id="access-via-slicing" class="level3">
<h3 class="anchored" data-anchor-id="access-via-slicing">Access via slicing</h3>
<p>As noted in the previous section skimage images are stored as NumPy arrays, so we can use array slicing to select rectangular areas of an image. Then, we can save the selection as a new image, change the pixels in the image, and so on. It is important to remember that coordinates are specified in (ry, cx) order and that colour values are specified in (r, g, b) order when doing these manipulations.</p>
<p>Consider this image of a whiteboard, and suppose that we want to create a sub-image with just the portion that says “odd + even = odd,” along with the red box that is drawn around the words.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/3a2de3c9-8579-4c78-a103-cb2e28c441ce-1-5f191cbd-3949-4350-9e37-8491dfa40847.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">board.jpg</figcaption>
</figure>
</div>
<p>Using the same display technique we have used throughout this blog, we can determine the coordinates of the corners of the area we wish to extract by hovering the mouse near the points of interest and noting the coordinates. If we do that, we might settle on a rectangular area with an upper-left coordinate of (135, 60) and a lower-right coordinate of (480, 150), as shown in this version of the whiteboard picture:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/f4850b9c-3a9b-45ee-b974-34e07da31dc3-1-7e67780a-79a6-41d0-a668-737604a32efb.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">board-coordinates.jpg</figcaption>
</figure>
</div>
<p>Note that the coordinates in the preceding image are specified in (cx, ry) order. Now if our entire whiteboard image is stored as an skimage image named image, we can create a new image of the selected region with a statement like this:</p>
<pre><code>clip = image[60:151, 135:481, :]</code></pre>
<p>Our array slicing specifies the range of y-coordinates or rows first, 60:151, and then the range of x-coordinates or columns, 135:481. Note we go one beyond the maximum value in each dimension, so that the entire desired area is selected. The third part of the slice, :, indicates that we want all three colour channels in our new image.</p>
<p>A script to create the subimage would start by loading the image:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co"># load and display original image</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/board.jpg"</span>)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f93077220&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-31-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Then we use array slicing to create a new image with our selected area and then display the new image:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># extract, display, and save sub-image</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>clip <span class="op">=</span> image[<span class="dv">60</span>:<span class="dv">151</span>, <span class="dv">135</span>:<span class="dv">481</span>, :]</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(clip)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/clip.tif"</span>, image<span class="op">=</span>clip)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-32-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We can also change the values in an image.</p>
<ol type="1">
<li><p>First, we sample a single pixel’s colour at a particular location of the image, saving it in a variable named color, which creates a 1 × 1 × 3 NumPy array with the blue, green, and red colour values for the pixel located at (ry = 330, cx = 90).</p></li>
<li><p>Then, with the img[60:151, 135:481] = color command, we modify the image in the specified area. From a NumPy perspective, this changes all the pixel values within that range to array saved in the color variable. In this case, the command “erases” that area of the whiteboard, replacing the words with a beige colour, as shown in the final image produced by the program:</p></li>
</ol>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># replace clipped area with sampled color</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>image_copy <span class="op">=</span> image.copy()</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> image_copy[<span class="dv">330</span>, <span class="dv">90</span>]</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>image_copy[<span class="dv">60</span>:<span class="dv">151</span>, <span class="dv">135</span>:<span class="dv">481</span>] <span class="op">=</span> color</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image_copy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f9102ffd0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-33-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>::: {.callout<span class="op">-</span>important}</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Key Points:</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> images are read <span class="im">from</span> disk <span class="cf">with</span> the iio.imread() function</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> we create a window that automatically scales the displayed image <span class="cf">with</span> matplotlib <span class="kw">and</span> calling show() on the <span class="kw">global</span> figure <span class="bu">object</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> colour images can be transformed to grayscale using skimage.color.rgb2gray() <span class="kw">or</span>, <span class="kw">in</span> many cases, be read <span class="im">as</span> grayscale directly by passing the argument mode<span class="op">=</span><span class="st">"L"</span> to iio.imread()</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> we can resize images <span class="cf">with</span> the skimage.transform.resize() function</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> NumPy array commands, such <span class="im">as</span> image[image <span class="op">&lt;</span> <span class="dv">128</span>] <span class="op">=</span> <span class="dv">0</span>, can be used to manipulate the pixels of an image.</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> array slicing can be used to extract sub<span class="op">-</span>images <span class="kw">or</span> modify areas of images, e.g., clip <span class="op">=</span> image[<span class="dv">60</span>:<span class="dv">150</span>, <span class="dv">135</span>:<span class="dv">480</span>, :]</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> metadata <span class="kw">is</span> <span class="kw">not</span> retained when images are loaded <span class="im">as</span> skimage images</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>:::</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"># load and display original image</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/maize_cluster.jpg"</span>)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Original image"</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="co"># extract, display, and save sub-image</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="co"># WRITE YOUR CODE TO SELECT THE SUBIMAGE NAME clip HERE:</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>clip <span class="op">=</span> image[<span class="dv">0</span>:<span class="dv">1750</span>, <span class="dv">1500</span>:<span class="dv">2500</span>, :]</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>plt.imshow(clip)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Clipped image"</span>)</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span class="co"># WRITE YOUR CODE TO SAVE clip HERE</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>iio.imwrite(uri<span class="op">=</span><span class="st">"Images/clip.jpg"</span>, image<span class="op">=</span>clip)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-35-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-35-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
<section id="drawing-and-bitwise-operations" class="level2">
<h2 class="anchored" data-anchor-id="drawing-and-bitwise-operations">3. Drawing and Bitwise Operations</h2>
<p>The next sections cover a basic toolkit of skimage operators. With these tools, we will be able to create programs to perform simple analyses of images based on changes in colour or shape.</p>
<section id="drawing-on-images" class="level3">
<h3 class="anchored" data-anchor-id="drawing-on-images">Drawing on images</h3>
<p>Often we wish to select only a portion of an image to analyze, and ignore the rest. Creating a rectangular sub-image with slicing, as we did in section 2 is one option for simple cases. Another option is to create another special image, of the same size as the original, with white pixels indicating the region to save and black pixels everywhere else. Such an image is called a <strong><em>mask</em></strong>. In preparing a mask, we sometimes need to be able to draw a shape - a circle or a rectangle, say - on a black image. skimage provides tools to do that.</p>
<p>Consider this image of maize seedlings:</p>
<p><img src="Images/maize-seedlings.jpg" width="420" height="420"></p>
<p>Now, suppose we want to analyze only the area of the image containing the roots themselves; we do not care to look at the kernels, or anything else about the plants. Further, we wish to exclude the frame of the container holding the seedlings as well. Hovering over the image with our mouse, could tell us that the upper-left coordinate of the sub-area we are interested in is (44, 357), while the lower-right coordinate is (720, 740). These coordinates are shown in (x, y) order.</p>
<p>A Python program to create a <strong>mask</strong> to select only that area of the image would start with a now-familiar section of code to open and display the original image.As before, we first import the v3 submodule of imageio (imageio.v3). We also import the NumPy library, which we need to create the initial mask image. Then, we import the draw submodule of skimage. We load and display the initial image in the same way we have done before.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.draw</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and display the original image</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/maize-seedlings.tif"</span>)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f9073cd30&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-36-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="masking" class="level3">
<h3 class="anchored" data-anchor-id="masking">Masking</h3>
<p><img src="Images/mask.jpg" width="500" height="500"></p>
<p>NumPy allows indexing of images/arrays with <strong>“boolean”</strong> arrays of the same size. Indexing with a boolean array is also called <strong>mask indexing</strong>. The “pixels” in such a mask array can only take two values: True or False. When indexing an image with such a mask, only pixel values at positions where the mask is True are accessed. But first, we need to generate a mask array of the same size as the image. Luckily, the NumPy library provides a function to create just such an array. The next section of code shows how:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the basic mask</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>], dtype<span class="op">=</span><span class="st">"bool"</span>)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first argument to the <em><strong>ones()</strong> function is the shape of the original image, so that our mask will be exactly the same size as the original. Notice, that we have only used the first two indices of our shape. We omitted the channel dimension. Indexing with such a mask will change all channel values simultaneously. The second argument, dtype = “bool”, indicates that the elements in the array should be </em>booleans* - i.e., values are either True or False. Thus, even though we use np.ones() to create the mask, its pixel values are in fact not 1 but True. You could check this, e.g., by print(mask[0, 0]).</p>
<p>Next, we draw a filled, rectangle on the mask. The parameters of the rectangle() function (357, 44) and (740, 720), are the coordinates of the upper-left (start) and lower-right (end) corners of a rectangle in (ry, cx) order. The function returns the rectangle as row (rr) and column (cc) coordinate arrays:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw filled rectangle on the mask image</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co"># co-ordinates are (row, column)</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co"># first co-ord is top-left, second co-ord is bottom-right</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.rectangle(start<span class="op">=</span>(<span class="dv">357</span>, <span class="dv">44</span>), end<span class="op">=</span>(<span class="dv">740</span>, <span class="dv">720</span>))</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>mask[rr, cc] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Display mask image</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90de33a0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-38-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Check the documentation!
</div>
</div>
<div class="callout-body-container callout-body">
<p>When using an skimage function for the first time - or the fifth time - it is wise to check how the function is used, via the <a href="https://scikit-image.org/docs/dev/user_guide">skimage documentation</a> or other usage examples on programming-related sites such as <a href="https://stackoverflow.com/">Stack Overflow</a>. Basic information about skimage functions can be found interactively in Python, via commands like help(skimage) or help(skimage.draw.rectangle). Take notes in your lab notebook. And, it is always wise to run some test code to verify that the functions your program uses are behaving in the manner you intend.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variable naming conventions
</div>
</div>
<div class="callout-body-container callout-body">
<p>You may have wondered why we called the return values of the rectangle function <em>rr</em> and <em>cc</em>?! You may have guessed that <em>r</em> is short for row and <em>c</em> is short for column. However, the rectangle function returns mutiple rows and columns; thus we used a convention of doubling the letter r to <em>rr</em> (and c to <em>cc</em>) to indicate that those are multiple values. In fact it may have even been clearer to name those variables rows and columns; however this would have been also much longer. Whatever you decide to do, try to stick to some already existing conventions, such that it is easier for other people to understand your code.</p>
</div>
</div>
</section>
<section id="other-drawing-operations" class="level3">
<h3 class="anchored" data-anchor-id="other-drawing-operations">Other drawing operations</h3>
<p>There are other functions for drawing on images, in addition to the <strong><em>skimage.draw.rectangle()</em></strong> function. We can draw circles, lines, text, and other shapes as well. These drawing functions may be useful later on, to help annotate images that our programs produce. Practice some of these functions here.</p>
<p>Circles can be drawn with the skimage.draw.disk() function, which takes two parameters: the (ry, cx) point of the centre of the circle, and the radius of the circle. There is an optional shape parameter that can be supplied to this function. It will limit the output coordinates for cases where the circle dimensions exceed the ones of the image.</p>
<p>Lines can be drawn with the skimage.draw.line() function, which takes four parameters: the (ry, cx) coordinate of one end of the line, and the (ry, cx) coordinate of the other end of the line.</p>
<p>Other drawing functions supported by skimage can be found in the <a href="https://scikit-image.org/docs/dev/api/skimage.draw.html#module-skimage.draw">skimage reference pages</a>.</p>
<p>First let’s make an empty, black image with a size of 800x600 pixels:</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create the black canvas</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> np.zeros(shape<span class="op">=</span>(<span class="dv">600</span>, <span class="dv">800</span>, <span class="dv">3</span>), dtype<span class="op">=</span><span class="st">"uint8"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw a blue circle with centre (200, 300) in (ry, cx) coordinates, and radius 100</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.disk(center<span class="op">=</span>(<span class="dv">200</span>, <span class="dv">300</span>), radius<span class="op">=</span><span class="dv">100</span>, shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>])</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>image[rr, cc] <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw a green line from (400, 200) to (500, 700) in (ry, cx) coordinates</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.line(r0<span class="op">=</span><span class="dv">400</span>, c0<span class="op">=</span><span class="dv">200</span>, r1<span class="op">=</span><span class="dv">500</span>, c1<span class="op">=</span><span class="dv">700</span>)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>image[rr, cc] <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f9064a6e0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-42-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We could expand this solution, if we wanted, to draw rectangles, circles and lines at random positions within our black canvas. To do this, we could use the random python module, and the function random.randrange, which can produce random numbers within a certain range.</p>
<p>Let’s draw 15 randomly placed circles:</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create the black canvas</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> np.zeros(shape<span class="op">=</span>(<span class="dv">600</span>, <span class="dv">800</span>, <span class="dv">3</span>), dtype<span class="op">=</span><span class="st">"uint8"</span>)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="co"># draw a blue circle at a random location 15 times</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">15</span>):</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    rr, cc <span class="op">=</span> skimage.draw.disk(center<span class="op">=</span>(</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>         random.randrange(<span class="dv">600</span>),</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>         random.randrange(<span class="dv">800</span>)),</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>         radius<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>         shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>],</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    image[rr, cc] <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a><span class="co"># display the results</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f906bbaf0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-43-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We could expand this even further to also randomly choose whether to plot a rectangle, a circle, or a square. Again, we do this with the random module, now using the function <strong>random.random</strong> that returns a random number between 0.0 and 1.0.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw 15 random shapes (rectangle, circle or line) at random positions</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">15</span>):</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># generate a random number between 0.0 and 1.0 and use this to decide if we</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># want a circle, a line or a sphere</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> random.random()</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="fl">0.33</span>:</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># draw a blue circle at a random location</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        rr, cc <span class="op">=</span> skimage.draw.disk(center<span class="op">=</span>(</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>            random.randrange(<span class="dv">600</span>),</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>            random.randrange(<span class="dv">800</span>)),</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">=</span><span class="dv">50</span>,</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>],</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> x <span class="op">&lt;</span> <span class="fl">0.66</span>:</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># draw a green line at a random location</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>        rr, cc <span class="op">=</span> skimage.draw.line(</span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>            r0<span class="op">=</span>random.randrange(<span class="dv">600</span>),</span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>            c0<span class="op">=</span>random.randrange(<span class="dv">800</span>),</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>            r1<span class="op">=</span>random.randrange(<span class="dv">600</span>),</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>            c1<span class="op">=</span>random.randrange(<span class="dv">800</span>),</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">255</span>, <span class="dv">0</span>)</span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># draw a red rectangle at a random location</span></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>        rr, cc <span class="op">=</span> skimage.draw.rectangle(</span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a>            start<span class="op">=</span>(random.randrange(<span class="dv">600</span>), random.randrange(<span class="dv">800</span>)),</span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>            extent<span class="op">=</span>(<span class="dv">50</span>, <span class="dv">50</span>),</span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>],</span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> (<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a>    image[rr, cc] <span class="op">=</span> color</span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-35"><a href="#cb75-35" aria-hidden="true" tabindex="-1"></a><span class="co"># display the results</span></span>
<span id="cb75-36"><a href="#cb75-36" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb75-37"><a href="#cb75-37" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f906fb5e0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-44-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="image-modification" class="level3">
<h3 class="anchored" data-anchor-id="image-modification">Image modification</h3>
<p>All that remains is the task of modifying the image using our mask in such a way that the areas with True pixels in the mask are not shown in the image any more.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-18-contents" aria-controls="callout-18" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Now, consider the mask image we created above. The values of the mask that corresponds to the portion of the image we are interested in are all False, while the values of the mask that corresponds to the portion of the image we want to remove are all True. How do we change the original image using the mask?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-18" class="callout-18-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>When indexing the image using the mask, we access only those pixels at positions where the mask is True. So, when indexing with the mask, one can set those values to 0, and effectively remove them from the image.</p>
</div>
</div>
</div>
<p>Now we can write a Python program to use a mask to retain only the portions of our maize roots image that actually contains the seedling roots. We load the original image and create the mask in the same way as before:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the original image</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/maize-seedlings.tif"</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the basic mask</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>], dtype<span class="op">=</span><span class="st">"bool"</span>)</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw a filled rectangle on the mask image</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.rectangle(start<span class="op">=</span>(<span class="dv">357</span>, <span class="dv">44</span>), end<span class="op">=</span>(<span class="dv">740</span>, <span class="dv">720</span>))</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>mask[rr, cc] <span class="op">=</span> <span class="va">False</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we use numpy indexing to remove the portions of the image, where the mask is True:</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply the mask</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>image[mask] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we display the masked image.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90c853f0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-47-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="masked-monster-truck" class="level3">
<h3 class="anchored" data-anchor-id="masked-monster-truck">Masked monster truck</h3>
<p>I’ll now try to mask an image of <em>32 Degrees</em> from my son’s monster truck collection!</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and display the original image</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/monster_truck.jpg"</span>)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90c86470&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-48-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the basic mask</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>], dtype<span class="op">=</span><span class="st">"bool"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw filled rectangle on the mask image</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.rectangle(start<span class="op">=</span>(<span class="dv">900</span>, <span class="dv">900</span>), end<span class="op">=</span>(<span class="dv">2200</span>, <span class="dv">3000</span>))</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>mask[rr, cc] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Display mask image</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>plt.imshow(mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90c85810&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-50-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>image_copy <span class="op">=</span> image.copy()</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply the mask</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>image_copy[mask] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>plt.imshow(image_copy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f910be050&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-52-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="masking---iterating-through-a-co-ordinates-file" class="level3">
<h3 class="anchored" data-anchor-id="masking---iterating-through-a-co-ordinates-file">Masking - iterating through a co-ordinates file</h3>
<p>Consider this image of a 96-well plate that has been scanned on a flatbed scanner:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the image</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/wellplate-01.jpg"</span>)</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the image</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90fe3d90&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-53-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Suppose that we are interested in the colours of the solutions in each of the wells. We do not care about the colour of the rest of the image, i.e., the plastic that makes up the well plate itself.</p>
<p>Your task is to write some code that will produce a mask that will mask out everything except for the wells. To help with this, you should use the text file <em>data/centers.txt</em> that contains the (cx, ry) coordinates of the centre of each of the 96 wells in this image. You may assume that each of the wells has a radius of 16 pixels. Your program should produce output that looks like this:</p>
<p><img src="Images/wellplate_masked.jpg" width="300" height="300"></p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read in original image</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/wellplate-01.jpg"</span>)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create the mask image</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>], dtype<span class="op">=</span><span class="st">"bool"</span>)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="co"># open and iterate through the centers file...</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"Images/centers.txt"</span>, <span class="st">"r"</span>) <span class="im">as</span> center_file:</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> center_file:</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... getting the coordinates of each well...</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>        coordinates <span class="op">=</span> line.split()</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>        cx <span class="op">=</span> <span class="bu">int</span>(coordinates[<span class="dv">0</span>])</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>        ry <span class="op">=</span> <span class="bu">int</span>(coordinates[<span class="dv">1</span>])</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... and drawing a circle on the mask</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        rr, cc <span class="op">=</span> skimage.draw.disk(center<span class="op">=</span>(ry, cx), radius<span class="op">=</span><span class="dv">16</span>, shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>])</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        mask[rr, cc] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a><span class="co"># apply the mask</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>image_copy <span class="op">=</span> image.copy()</span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>image_copy[mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a><span class="co"># display the result</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>plt.imshow(image_copy)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f905eabc0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-54-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="masking---using-nested-for-loops" class="level3">
<h3 class="anchored" data-anchor-id="masking---using-nested-for-loops">Masking - using nested for loops</h3>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read in original image</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/wellplate-01.jpg"</span>)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create the mask image</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.ones(shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>], dtype<span class="op">=</span><span class="st">"bool"</span>)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="co"># upper left well coordinates</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>cx0 <span class="op">=</span> <span class="dv">91</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>ry0 <span class="op">=</span> <span class="dv">108</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="co"># spaces between wells</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>deltaCX <span class="op">=</span> <span class="dv">70</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>deltaRY <span class="op">=</span> <span class="dv">72</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>cx <span class="op">=</span> cx0</span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>ry <span class="op">=</span> ry0</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a><span class="co"># iterate each row and column</span></span>
<span id="cb93-19"><a href="#cb93-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">12</span>):</span>
<span id="cb93-20"><a href="#cb93-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># reset cx to leftmost well in the row</span></span>
<span id="cb93-21"><a href="#cb93-21" aria-hidden="true" tabindex="-1"></a>    cx <span class="op">=</span> cx0</span>
<span id="cb93-22"><a href="#cb93-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>):</span>
<span id="cb93-23"><a href="#cb93-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-24"><a href="#cb93-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... and drawing a circle on the mask</span></span>
<span id="cb93-25"><a href="#cb93-25" aria-hidden="true" tabindex="-1"></a>        rr, cc <span class="op">=</span> skimage.draw.disk(center<span class="op">=</span>(ry, cx), radius<span class="op">=</span><span class="dv">16</span>, shape<span class="op">=</span>image.shape[<span class="dv">0</span>:<span class="dv">2</span>])</span>
<span id="cb93-26"><a href="#cb93-26" aria-hidden="true" tabindex="-1"></a>        mask[rr, cc] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb93-27"><a href="#cb93-27" aria-hidden="true" tabindex="-1"></a>        cx <span class="op">+=</span> deltaCX</span>
<span id="cb93-28"><a href="#cb93-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># after one complete row, move to next row</span></span>
<span id="cb93-29"><a href="#cb93-29" aria-hidden="true" tabindex="-1"></a>    ry <span class="op">+=</span> deltaRY</span>
<span id="cb93-30"><a href="#cb93-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-31"><a href="#cb93-31" aria-hidden="true" tabindex="-1"></a><span class="co"># apply the mask</span></span>
<span id="cb93-32"><a href="#cb93-32" aria-hidden="true" tabindex="-1"></a>copy_image<span class="op">=</span>image.copy()</span>
<span id="cb93-33"><a href="#cb93-33" aria-hidden="true" tabindex="-1"></a>copy_image[mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb93-34"><a href="#cb93-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-35"><a href="#cb93-35" aria-hidden="true" tabindex="-1"></a><span class="co"># display the result</span></span>
<span id="cb93-36"><a href="#cb93-36" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb93-37"><a href="#cb93-37" aria-hidden="true" tabindex="-1"></a>plt.imshow(copy_image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f905ea080&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-55-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>we can use the NumPy zeros() function to create a blank, black image</li>
<li>we can draw on skimage images with functions such as skimage.draw.rectangle(), skimage.draw.disk(), skimage.draw.line(), and more</li>
<li>the drawing functions return indices to pixels that can be set directly</li>
</ul>
</div>
</div>
</section>
</section>
<section id="creating-histograms" class="level2">
<h2 class="anchored" data-anchor-id="creating-histograms">4. Creating Histograms</h2>
<p>In this section, we will learn how to use skimage functions to create and display histograms for images.</p>
<section id="introduction-to-histograms" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to-histograms">Introduction to Histograms</h3>
<p>As it pertains to images, a histogram is a graphical representation showing how frequently various colour values occur in the image. We saw in section 1 that we could use a histogram to visualise the differences in uncompressed and compressed image formats. If our project involves detecting colour changes between images, histograms will prove to be very useful, and histograms are also quite handy as a preparatory step before performing thresholding.</p>
</section>
<section id="grayscale-histograms" class="level3">
<h3 class="anchored" data-anchor-id="grayscale-histograms">Grayscale Histograms</h3>
<p>We will start with grayscale images, and then move on to colour images. We will use an image of a plant seedling as an example. ere we load the image in grayscale instead of full colour, and display it.</p>
<p>Again, we use the iio.imread() function to load our image. The first argument to iio.imread() is the filename of the image. The second argument mode=“L” defines the type and depth of a pixel in the image (e.g., an 8-bit pixel has a range of 0-255). This argument is forwarded to the pillow backend, for which mode “L” means 8-bit pixels and single-channel (i.e., grayscale). pillow is a Python imaging library; which backend is used by iio.imread() may be specified (to use pillow, you would pass this argument: plugin=“pillow”); if unspecified, iio.imread() determines the backend to use based on the image type.</p>
<p>Then, we convert the grayscale image of integer dtype, with 0-255 range, into a floating-point one with 0-1 range, by calling the function <strong>skimage.util.img_as_float</strong>. We will keep working with images in the value range 0 to 1 in this section.</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.util</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a><span class="co"># read the image of a plant seedling as grayscale from the outset</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/plant-seedling.jpg"</span>, mode<span class="op">=</span><span class="st">"L"</span>)</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a><span class="co"># convert the image to float dtype with a value range from 0 to 1</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> skimage.util.img_as_float(image)</span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a><span class="co"># display the image</span></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>plt.imshow(image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f90393a60&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-56-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We now use the function <strong>np.histogram</strong> to compute the histogram of our image which, after all, is a NumPy array.</p>
<p>The parameter <strong><em>bins</em></strong> determines the number of “bins” to use for the histogram. We pass in 256 because we want to see the pixel count for each of the 256 possible values in the grayscale image.</p>
<p>The parameter <strong><em>range</em></strong> is the range of values each of the pixels in the image can have. Here, we pass 0 and 1, which is the value range of our input image after transforming it to grayscale.</p>
<p>The first output of the np.histogram function is a one-dimensional NumPy array, with 256 rows and one column, representing the number of pixels with the intensity value corresponding to the index. I.e., the first number in the array is the number of pixels found with intensity value 0, and the final number in the array is the number of pixels found with intensity value 255.</p>
<p>The second output of np.histogram is an array with the bin edges and one column and 257 rows (one more than the histogram itself). There are no gaps between the bins, which means that the end of the first bin, is the start of the second and so on. For the last bin, the array also has to contain the stop, so it has one more element, than the histogram.</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create the histogram</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(image, bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we turn our attention to displaying the histogram, by taking advantage of the plotting facilities of the matplotlib library. We create the plot with plt.figure(), then label the figure and the coordinate axes with plt.title(), plt.xlabel(), and plt.ylabel() functions. We then set the limits on the values on the x-axis with the plt.xlim([0.0, 1.0]) function call, before creating the histogram plot itself with plt.plot(bin_edges[0:-1], histogram).</p>
<p>We use the <strong>left</strong> bin edges as x-positions for the histogram values by indexing the bin_edges array to ignore the last value (the <strong>right</strong> edge of the last bin). When we run the program on this image of a plant seedling, it produces this histogram:</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co"># configure and draw the histogram figure</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale Histogram"</span>)</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"grayscale value"</span>)</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixel count"</span>)</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="fl">0.0</span>, <span class="fl">1.0</span>])  <span class="co"># &lt;- named arguments do not work here</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)  <span class="co"># &lt;- or here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-58-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note that we cannot used named parameters for the plt.xlim() or plt.plot() functions.
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is because these functions are defined to take an arbitrary number of unnamed arguments. The designers wrote the functions this way because they are very versatile, and creating named parameters for all of the possible ways to use them would be complicated.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Matplotlib provides a dedicated function to compute and display histograms: <strong>plt.hist()</strong>.
</div>
</div>
<div class="callout-body-container callout-body">
<p>We will not use it in this section in order to understand how to calculate histograms in more detail. In practice, it is a good idea to use this function, because it visualises histograms more appropriately than plt.plot(). Here, we could use it by calling:</p>
<pre><code>**plt.hist(image.flatten(), bins=256, range=(0, 1))** </code></pre>
<p>instead of np.histogram() and plt.plot()</p>
<p><strong>.flatten()</strong> is a numpy function that converts our two-dimensional image into a one-dimensional array.This is because these functions are defined to take an arbitrary number of unnamed arguments. The designers wrote the functions this way because they are very versatile, and creating named parameters for all of the possible ways to use them would be complicated.</p>
</div>
</div>
<p>Looking at the histogram above, you will notice that there is a large number of very dark pixels, as indicated in the chart by the spike around the grayscale value 0.12. That is not so surprising, since the original image is mostly black background. What if we want to focus more closely on the leaf of the seedling? That is where a mask enters the picture!</p>
<p>Let’s hover over the plant seedling image with your mouse to determine the (x, y) coordinates of a bounding box around the leaf of the seedling. Then, using techniques from section 3, we can create a mask with a white rectangle covering that bounding box. After we have created the mask, we can apply it to the input image before passing it to the np.histogram function.</p>
<div class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and display the original image</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/plant-seedling.jpg"</span>, mode <span class="op">=</span> <span class="st">"L"</span>)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display the image</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f8ba21de0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-59-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>copy_image <span class="op">=</span> image.copy()</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create mask here, using np.zeros() and skimage.draw.rectangle()</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.zeros(shape<span class="op">=</span>copy_image.shape, dtype<span class="op">=</span><span class="st">"bool"</span>)</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw filled rectangle on the mask image</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="co"># co-ordinates are (row, column)</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a><span class="co"># first co-ord is top-left, second co-ord is bottom-right</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>rr, cc <span class="op">=</span> skimage.draw.rectangle(start<span class="op">=</span>(<span class="dv">199</span>,<span class="dv">410</span>), end<span class="op">=</span>(<span class="dv">384</span>,<span class="dv">485</span>))</span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>mask[rr, cc] <span class="op">=</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the mask</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="89">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f8b83b700&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-61-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># mask the image and create the new histogram</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(copy_image[mask], bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="co"># configure and draw the histogram figure</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale Histogram"</span>)</span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"grayscale value"</span>)</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixel count"</span>)</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="fl">0.0</span>, <span class="fl">1.0</span>])</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Your histogram of the masked area should look something like this:</p>
<p><img src="Images/plant-seedling-grayscale-histogram-mask.png" width="600" height="600"></p>
</section>
<section id="colour-histograms" class="level3">
<h3 class="anchored" data-anchor-id="colour-histograms">Colour Histograms</h3>
<p>We can also create histograms for full colour images, in addition to grayscale histograms. We have seen colour histograms before, in the first section. A program to create colour histograms starts in a familiar way. We read the original image, now in full colour, and display it:</p>
<div class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read original image, in full color</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/plant-seedling.jpg"</span>)</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="co"># display the image</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f2f8b772980&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-63-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Next, we create the histogram, by calling the np.histogram function three times, once for each of the channels. We obtain the individual channels, by slicing the image along the last axis. For example, we can obtain the red colour channel by calling:</p>
<pre><code>r_chan = image[:, :, 0]</code></pre>
<p>We will draw the histogram line for each channel in a different colour, and so we create a tuple of the colours to use for the three lines with the:</p>
<pre><code>colors = ("red", "green", "blue")</code></pre>
<p>line of code. Then, we limit the range of the x-axis with the <em>plt.xlim()</em> function call.</p>
<p>Next, we use the for control structure to iterate through the three channels, plotting an appropriately-coloured histogram line for each. This may be new Python syntax for you, so we will take a moment to discuss what is happening in the for statement.</p>
<p>The Python built-in <strong><em>enumerate()</em></strong> function takes a list and returns an iterator of tuples, where the first element of the tuple is the <strong>index</strong> and the second element is the <strong>element</strong> of the list.</p>
<div class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co"># tuple to select colors of each channel line</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> (<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create the histogram plot, with three lines, one for</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="co"># each color</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="dv">0</span>, <span class="dv">256</span>])</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a><span class="co"># using a tuple, (channel_id, color), as the for variable</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> channel_id, color <span class="kw">in</span> <span class="bu">enumerate</span>(colors):</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>    histogram, bin_edges <span class="op">=</span> np.histogram(</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>        image[:, :, channel_id], bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="dv">0</span>, <span class="dv">256</span>)</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>    plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram, color<span class="op">=</span>color)</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a><span class="co"># label our axes and display the histogram</span></span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Color Histogram"</span>)</span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Color value"</span>)</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Pixel count"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="101">
<pre><code>Text(0, 0.5, 'Pixel count')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-64-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>In our colour histogram program, we are using a tuple, (channel_id, color), as the for variable. The first time through the loop, the channel_id variable takes the value 0, referring to the position of the red colour channel, and the color variable contains the string “red”. The second time through the loop the values are the green channels index 1 and “green”, and the third time they are the blue channel index 2 and “blue”.</p>
<p>Inside the for loop, our code looks much like it did for the grayscale example. We calculate the histogram for the current channel with the:</p>
<pre><code>histogram, bin_edges = np.histogram(image[:, :, channel_id], bins=256, range=(0, 256))</code></pre>
<p>function call, and then add a histogram line of the correct colour to the plot with the:</p>
<pre><code>plt.plot(bin_edges[0:-1], histogram, color=color)</code></pre>
<p>function call.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Iterators, tuples, and enumerate()
</div>
</div>
<div class="callout-body-container callout-body">
<p>In Python, an iterator, or an iterable object, is something that can be iterated over with the for control structure. A <strong>tuple</strong> is a sequence of objects, just like a list. However, a tuple <strong>cannot be changed</strong>, and a tuple is indicated by (parentheses) instead of [square brackets]. The enumerate() function takes an iterable object, and returns an iterator of tuples consisting of the 0-based index and the corresponding object.</p>
</div>
</div>
<p>For example, consider this small Python program:</p>
<div class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span> <span class="op">=</span> (<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>)</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">list</span>):</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(0, 'a')
(1, 'b')
(2, 'c')
(3, 'd')
(4, 'e')</code></pre>
</div>
</div>
</section>
<section id="colour-histogram-with-a-mask" class="level3">
<h3 class="anchored" data-anchor-id="colour-histogram-with-a-mask">Colour histogram with a mask</h3>
<p>We can also apply a mask to the images we apply the colour histogram process to, in the same way we did for grayscale histograms. Consider this image of a well plate, where various chemical sensors have been applied to water and various concentrations of hydrochloric acid and sodium hydroxide:</p>
<p><img src="Images/wellplate-02.jpg" width="400" height="400"></p>
<p>Suppose we are interested in the colour histogram of one of the sensors in the well plate image, specifically, the seventh well from the left in the topmost row, which shows Erythrosin B reacting with water.Hover over the image with your mouse to find the centre of that well and the radius (in pixels) of the well. Then create a circular mask to select only the desired well. Then, use that mask to apply the colour histogram operation to that well.</p>
<p>Your masked image should look like this:</p>
<p><img src="Images/wellplate-02-masked.jpg" width="400" height="400"></p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>in many cases, we can load images in grayscale by passing the mode=“L” argument to the iio.imread() function.</li>
<li>we can create histograms of images with the np.histogram function.</li>
<li>we can separate the RGB channels of an image using slicing operations.</li>
<li>we can display histograms using the matplotlib pyplot <em>figure()</em>, <em>title()</em>, <em>xlabel()</em>, <em>ylabel()</em>, <em>xlim()</em>, <em>plot()</em>, and <em>show()</em> functions.</li>
</ul>
</div>
</div>
</section>
</section>
<section id="blurring-images" class="level2">
<h2 class="anchored" data-anchor-id="blurring-images">5. Blurring Images</h2>
<p>In this section, we will learn how to use skimage functions to blur images.</p>
<p>When processing an image, we are often interested in identifying objects represented within it so that we can perform some further analysis of these objects e.g.&nbsp;by counting them, measuring their sizes, etc. An important concept associated with the identification of objects in an image is that of <strong>edges</strong>: the lines that represent a transition from one group of similar pixels in the image to another different group. One example of an edge is the pixels that represent the boundaries of an object in an image, where the background of the image ends and the object begins.</p>
<p>When we blur an image, we make the colour transition from one side of an edge in the image to another smooth rather than sudden. The effect is to average out rapid changes in pixel intensity. A blur is a very common operation we need to perform before other tasks such as <strong>thresholding</strong>.</p>
<p>There are several different blurring functions in the <strong>skimage.filters</strong> module, so we will focus on just one here, the <em>Gaussian blur</em>.</p>
<section id="filters" class="level3">
<h3 class="anchored" data-anchor-id="filters">Filters</h3>
<p>In the day-to-day, macroscopic world, we have physical filters which separate out objects by size. A filter with small holes allows only small objects through, leaving larger objects behind. This is a good analogy for image filters. A high-pass filter will retain the smaller details in an image, filtering out the larger ones. A low-pass filter retains the larger features, analogous to what’s left behind by a physical filter mesh. High- and low-pass, here, refer to high and low spatial frequencies in the image. Details associated with high spatial frequencies are small, a lot of these features would fit across an image. Features associated with low spatial frequencies are large - maybe a couple of big features per image.</p>
</section>
<section id="blurring" class="level3">
<h3 class="anchored" data-anchor-id="blurring">Blurring</h3>
<p>Blurring is to make something less clear or distinct. This could be interpreted quite broadly in the context of image analysis - anything that reduces or distorts the detail of an image might apply. Applying a low pass filter, which removes detail occurring at high spatial frequencies, is perceived as a blurring effect. A Gaussian blur is a filter that makes use of a Gaussian kernel.</p>
</section>
<section id="kernels" class="level3">
<h3 class="anchored" data-anchor-id="kernels">Kernels</h3>
<p>A kernel can be used to implement a filter on an image. A kernel, in this context, is a small matrix which is combined with the image using a mathematical technique: convolution. Different sizes, shapes and contents of kernel produce different effects. The kernel can be thought of as a little image in itself, and will favour features of a similar size and shape in the main image. On convolution with an image, a big, blobby kernel will retain big, blobby, low spatial frequency features.</p>
</section>
<section id="gaussian-blur" class="level3">
<h3 class="anchored" data-anchor-id="gaussian-blur">Gaussian blur</h3>
<p>Consider this image of a cat, in particular the area of the image outlined by the white square.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/069f154d-17de-4ab1-9abe-8445b2706ba7-1-90daf2ae-b8e2-4ebc-bba9-fd142d8421e2.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">cat.jpg</figcaption>
</figure>
</div>
<p>Now, zoom in on the area of the cat’s eye, as shown in the left-hand image below. When we apply a filter, we consider each pixel in the image, one at a time. In this example, the pixel we are currently working on is highlighted in red, as shown in the right-hand image.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/c66ea0d7-18f3-447c-9964-525f3e557dff-1-020c950f-b7ea-44d7-8a3c-d26e18dd68b1.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">cat-eye-pixels.jpg</figcaption>
</figure>
</div>
<p>When we apply a filter, we consider rectangular groups of pixels surrounding each pixel in the image, in turn. The <em>kernel</em> is another group of pixels (a separate matrix / small image), of the same dimensions as the rectangular group of pixels in the image, that moves along with the pixel being worked on by the filter. The width and height of the kernel must be an odd number, so that the pixel being worked on is always in its centre. In the example shown above, the kernel is square, with a dimension of seven pixels.</p>
<p>To apply the kernel to the current pixel, an average of the the colour values of the pixels surrounding it is calculated, weighted by the values in the kernel. In a <strong>Gaussian</strong> blur, the pixels nearest the centre of the kernel are given more weight than those far away from the centre. The rate at which this weight diminishes is determined by a Gaussian function, hence the name Gaussian blur.</p>
<p>A Gaussian function maps random variables into a <strong>normal distribution</strong> or <em>“Bell Curve”</em>.</p>
<p><img src="Images/Normal_Distribution.svg" width="600" height="600"></p>
<p>https://en.wikipedia.org/wiki/Gaussian_function#/media/File:Normal_Distribution_PDF.svg</p>
<p>The shape of the function is described by a <strong>mean</strong> value <em>μ</em>, and a <strong>variance</strong> value <em>σ²</em>. The mean determines the central point of the bell curve on the x axis, and the variance describes the spread of the curve. In fact, when using Gaussian functions in Gaussian blurring, we use a 2D Gaussian function to account for X and Y dimensions, but the same rules apply. The mean μ is always 0, and represents the middle of the 2D kernel. Increasing values of σ² in either dimension increases the amount of blurring in that dimension.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/361b4075-d8d4-4df4-ac50-cacea2a3f670-1-4adc2188-fae0-4d39-97c2-2c0c242b13ec.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Gaussian_2D.png</figcaption>
</figure>
</div>
<p>The averaging is done on a <strong>channel-by-channel</strong> basis, and the average channel values become the new value for the pixel in the filtered image. Larger kernels have more values factored into the average, and this implies that a larger kernel will blur the image more than a smaller kernel. To get an idea of how this works, consider this plot of the two-dimensional Gaussian function:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/a2a47316-bb54-4b4a-b75d-3a30db7ddfbf-1-2a56c4bb-901f-430a-957b-05615109013c.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">gaussian-kernel.png</figcaption>
</figure>
</div>
<p>Imagine that plot laid over the kernel for the Gaussian blur filter. The height of the plot corresponds to the weight given to the underlying pixel in the kernel. I.e., the pixels close to the centre become more important to the filtered pixel colour than the pixels close to the outer limits of the kernel. The shape of the Gaussian function is controlled via its standard deviation, or sigma:</p>
<ul>
<li>a large sigma value results in a flatter shape, while</li>
<li>a smaller sigma value results in a more pronounced peak.</li>
</ul>
<p>The mathematics involved in the Gaussian blur filter are not quite that simple, but this explanation gives you the basic idea. To illustrate the blur process, consider the blue channel colour values from the seven-by-seven region of the cat image above:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/43a23411-783f-41f8-b282-478288c5bf39-1-63743bf3-cd76-411a-a744-cac637d4a660.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">cat-corner-blue.png</figcaption>
</figure>
</div>
<p>The filter is going to determine the new blue channel value for the centre pixel – the one that currently has the value 86. The filter calculates a weighted average of all the blue channel values in the kernel giving higher weight to the pixels near the centre of the kernel.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/6e404fba-2d52-48e0-848e-93cc34b3bff7-1-e409e806-8f4b-4bf7-ad36-cac2cf96946c.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">combination.png</figcaption>
</figure>
</div>
<p>This weighted average, the sum of the multiplications, becomes the new value for the centre pixel (3, 3). The same process would be used to determine the green and red channel values, and then the kernel would be moved over to apply the filter to the next pixel in the image.</p>
</section>
<section id="image-edges" class="level3">
<h3 class="anchored" data-anchor-id="image-edges">Image edges</h3>
<p>Something different needs to happen for pixels near the outer limits of the image, since the kernel for the filter may be partially off the image. For example, what happens when the filter is applied to the upper-left pixel of the image? Here are the blue channel pixel values for the upper-left pixel of the cat image, again assuming a seven-by-seven kernel:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/794bcfff-7194-4a68-80bb-ffd82790f39d-1-3be43e17-88db-4def-af8c-62229f0377eb.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">edges.JPG</figcaption>
</figure>
</div>
<p>The upper-left pixel is the one with value 4. Since the pixel is at the upper-left corner, there are no pixels underneath much of the kernel; here, this is represented by x’s. So, what does the filter do in that situation? The default mode is to fill in the nearest pixel value from the image. For each of the missing x’s the image value closest to the x is used. If we fill in a few of the missing pixels, you will see how this works:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/c05b72cb-b39f-4c8f-a750-a3e209233ca5-1-2d28eaed-5ba1-47e8-b1be-75c47ea71328.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">edges_2.JPG</figcaption>
</figure>
</div>
<p>Another strategy to fill those missing values is to <strong><em>reflect</em></strong> the pixels that are in the image to fill in for the pixels that are missing from the kernel.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/15656129-c95e-401d-b6df-8b93bb70e204-1-78041d9a-a75b-442f-b6e9-866cf1beed58.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">reflect.JPG</figcaption>
</figure>
</div>
<p>A similar process would be used to fill in all of the other missing pixels from the kernel. Other <strong><em>border modes</em></strong> are available; you can learn more about them in the <a href="https://scikit-image.org/docs/dev/user_guide">skimage documentation</a>. This animation shows how the blur kernel moves along in the original image in order to calculate the colour channel values for the blurred image.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/b4c59e4f-735c-444b-b676-9734bf4e337c-1-ae8404cc-4024-478f-a356-d6d6a43b9e89.gif" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">blur-demo.gif</figcaption>
</figure>
</div>
<p>skimage has built-in functions to perform blurring for us, so we do not have to perform all of these mathematical operations ourselves. Let’s work through an example of blurring an image with the skimage Gaussian blur function.</p>
<p>First, we load the image, and display it:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.filters</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/gaussian-original.png"</span>)</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display the image</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7fa014b526e0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-66-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Next, we apply the gaussian blur:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">3.0</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="co"># apply Gaussian blur, creating a new image</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>blurred <span class="op">=</span> skimage.filters.gaussian(</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    image, sigma<span class="op">=</span>(sigma, sigma), truncate<span class="op">=</span><span class="fl">3.5</span>, channel_axis<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first two parameters to <strong>skimage.filters.gaussian()</strong> are the image to blur, <em>image</em>, and a <em>tuple defining the sigma to use in ry- and cx-direction</em>, (sigma, sigma). The third parameter <em>truncate</em> gives the radius of the kernel in terms of sigmas. A Gaussian function is defined from -infinity to +infinity, but our kernel (which must have a finite, smaller size) can only approximate the real function. Therefore, we must choose a certain distance from the centre of the function where we stop this approximation, and set the final size of our kernel. In the above example, we set truncate to 3.5, which means the kernel size will be 2 * sigma * 3.5. For example, for a sigma of 1.0 the resulting kernel size would be 7, while for a sigma of 2.0 the kernel size would be 14. <strong>The default value for truncate in scikit-image is 4.0.</strong></p>
<p>The last parameter to skimage.filters.gaussian() tells skimage to interpret our image, that has three dimensions, as a multichannel colour image.</p>
<p>Finally, we display the blurred image:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co"># display blurred image</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fdadf2500&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-68-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The size and shape of the kernel used to blur an image can have a significant effect on the result of the blurring and any downstream analysis carried out on the blurred image. Let’s now experiment with the sigma values of the kernel, as this is a good way to develop our understanding of how the choice of kernel can influence the result of blurring.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-24-contents" aria-controls="callout-24" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Generally speaking, what effect does the sigma value have on the blurred image?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-24" class="callout-24-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Generally speaking, the larger the sigma value, the more blurry the result. A larger sigma will tend to get rid of more noise in the image, which will help for other operations we will cover soon, such as thresholding. However, a larger sigma also tends to eliminate some of the detail from the image. So, we must strike a balance with the sigma value used for blur filters.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="co"># apply Gaussian blur, creating a new image</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>blurred <span class="op">=</span> skimage.filters.gaussian(</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    image, sigma<span class="op">=</span>(sigma, sigma), truncate<span class="op">=</span><span class="fl">3.5</span>, channel_axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display blurred image</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda93f7f0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-69-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">5.0</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="co"># apply Gaussian blur, creating a new image</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>blurred <span class="op">=</span> skimage.filters.gaussian(</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    image, sigma<span class="op">=</span>(sigma, sigma), truncate<span class="op">=</span><span class="fl">3.5</span>, channel_axis<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display blurred image</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda9b6470&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-70-output-3.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-25-contents" aria-controls="callout-25" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Kernel shape - what is the effect of applying an asymmetric kernel to blurring an image?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-25" class="callout-25-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>These unequal sigma values produce a kernel that is rectangular instead of square. The result is an image that is much more blurred in the x direction than the y direction or vice versa. For most use cases, a uniform blurring effect is desirable and this kind of asymmetric blurring should be avoided. However, it can be helpful in specific circumstances e.g.&nbsp;when noise is present in your image in a particular pattern or orientation, such as vertical lines, or when you want to <a href="https://www.researchgate.net/publication/228567435_An_edge_detection_algorithm_based_on_rectangular_Gaussian_kernels_for_machine_vision_applications">remove uniform noise without blurring edges present in the image in a particular orientation</a>.</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="co"># apply Gaussian blur, with a sigma of 1.0 in the ry direction, and 6.0 in the cx direction</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>blurred <span class="op">=</span> skimage.filters.gaussian(</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    image, sigma<span class="op">=</span>(<span class="fl">1.0</span>, <span class="fl">6.0</span>), truncate<span class="op">=</span><span class="fl">3.5</span>, multichannel<span class="op">=</span><span class="va">True</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a><span class="co"># display blurred image</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_2635/3991388852.py:2: FutureWarning: `multichannel` is a deprecated argument name for `gaussian`. It will be removed in version 1.0. Please use `channel_axis` instead.
  blurred = skimage.filters.gaussian(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda82f160&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-71-output-3.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co"># apply Gaussian blur, with a sigma of 6.0 in the ry direction, and 1.0 in the cx direction</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>blurred <span class="op">=</span> skimage.filters.gaussian(</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    image, sigma<span class="op">=</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>), truncate<span class="op">=</span><span class="fl">3.5</span>, multichannel<span class="op">=</span><span class="va">True</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="co"># display blurred image</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_2635/1775552283.py:2: FutureWarning: `multichannel` is a deprecated argument name for `gaussian`. It will be removed in version 1.0. Please use `channel_axis` instead.
  blurred = skimage.filters.gaussian(</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda8a3ca0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-72-output-3.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="other-methods-of-blurring" class="level3">
<h3 class="anchored" data-anchor-id="other-methods-of-blurring">Other methods of blurring</h3>
<p>The Gaussian blur is a way to apply a low-pass filter in skimage. It is often used to remove Gaussian (i. e., random) noise from the image. For other kinds of noise, e.g.&nbsp;“salt and pepper” or “static” noise, a median filter is typically used. See the <a href="https://scikit-image.org/docs/dev/api/skimage.filters.html#module-skimage.filters">skimage.filters documentation</a> for a list of available filters.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>applying a low-pass blurring filter smooths edges and removes noise from an image</li>
<li>blurring is often used as a first step before we perform thresholding or edge detection</li>
<li>the Gaussian blur can be applied to an image with the skimage.filters.gaussian() function</li>
<li>larger sigma values may remove more noise, but they will also remove detail from an image</li>
</ul>
</div>
</div>
</section>
</section>
<section id="thresholding" class="level2">
<h2 class="anchored" data-anchor-id="thresholding">6. Thresholding</h2>
<p>In this section, we will learn how to use skimage functions to apply thresholding to an image. Thresholding is a type of image segmentation, where we change the pixels of an image to make the image easier to analyze. In thresholding, we convert an image from colour or grayscale into a binary image, i.e., one that is simply black and white. Most frequently, we use thresholding as a way to select areas of interest of an image, while ignoring the parts we are not concerned with. We have already done some simple thresholding, in section 2 <em>Working with skimage</em>. In that case, we used a simple NumPy array manipulation to separate the pixels belonging to the root system of a plant from the black background. In this section, we will learn how to use skimage functions to perform thresholding. Then, we will use the masks returned by these functions to select the parts of an image we are interested in.</p>
<section id="simple-thresholding" class="level3">
<h3 class="anchored" data-anchor-id="simple-thresholding">Simple thresholding</h3>
<p>Consider the image Images/shapes-01.jpg with a series of crudely cut shapes set against a white background.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> glob</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.filters</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a><span class="co"># load the image</span></span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/shapes-01.jpg"</span>)</span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fdae61720&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-73-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Now suppose we want to select only the shapes from the image. In other words, we want to leave the pixels belonging to the shapes “on,” while turning the rest of the pixels “off,” by setting their colour channel values to zeros. The skimage library has several different methods of thresholding. We will start with the simplest version, which involves an important step of human input. Specifically, in this simple, <strong><em>fixed-level thresholding</em></strong>, we have to provide a threshold value t.</p>
<p>The process works like this. First, we will load the original image, convert it to grayscale, and de-noise it as in the <em>Blurring Images</em> section:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert the image to grayscale</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a><span class="co"># blur the image to denoise</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred_image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd9c5f850&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-74-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Next, we would like to apply the threshold t such that pixels with grayscale values on one side of t will be turned “on”, while pixels with grayscale values on the other side will be turned “off”. How might we do that? Remember that grayscale images contain pixel values in the range from 0 to 1, so we are looking for a threshold t in the closed range [0.0, 1.0]. We see in the image that the geometric shapes are “darker” than the white background but there is also some light gray noise on the background. One way to determine a “good” value for t is to look at the grayscale histogram of the image and try to identify what grayscale ranges correspond to the shapes in the image or the background.</p>
<p>The histogram for the shapes image shown above can be produced as in the Creating Histograms section.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a histogram of the blurred grayscale image</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(blurred_image, bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)</span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale Histogram"</span>)</span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"grayscale value"</span>)</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixels"</span>)</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>(0.0, 1.0)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-75-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Since the image has a white background, most of the pixels in the image are white. This corresponds nicely to what we see in the histogram: there is a peak near the value of 1.0. If we want to select the shapes and not the background, we want to turn off the white background pixels, while leaving the pixels for the shapes turned on. So, we should choose a value of t somewhere before the large peak and turn pixels above that value “off”. Let us choose t=0.8.</p>
<p>To apply the threshold t, we can use the numpy comparison operators to create a mask. Here, we want to turn “on” all pixels which have values smaller than the threshold, so we use the less operator &lt; to compare the blurred_image to the threshold t. The operator returns a mask, that we capture in the variable binary_mask. It has only one channel, and each of its values is either 0 or 1. The binary mask created by the thresholding operation can be shown with plt.imshow, where the False entries are shown as black pixels (0-valued) and the True entries are shown as white pixels (1-valued).</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a mask based on the threshold</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>binary_mask <span class="op">=</span> blurred_image <span class="op">&lt;</span> t</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(binary_mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda7add20&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-76-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>You can see that the areas where the shapes were in the original area are now white, while the rest of the mask image is black.</p>
</section>
<section id="what-makes-a-good-threshold" class="level3">
<h3 class="anchored" data-anchor-id="what-makes-a-good-threshold">What makes a good threshold?</h3>
<p>As is often the case, the answer to this question is “it depends”. In the example above, we could have just switched off all the white background pixels by choosing <em>t=1.0</em>, but this would leave us with some background noise in the mask image. On the other hand, if we choose too low a value for the threshold, we could lose some of the shapes that are too bright. We can experiment with the threshold by re-running the above code lines with different values for t.</p>
<p>In practice, it is a matter of domain knowledge and experience to interpret the peaks in the histogram so to determine an appropriate threshold. The process often involves trial and error, which is a drawback of the simple thresholding method. Below we will introduce <strong><em>automatic thresholding</em></strong>, which uses a quantitative, mathematical definition for a good threshold that allows us to determine the value of t automatically. It is worth noting that the principle for simple and automatic thresholding can also be used for images with pixel ranges other than [0.0, 1.0]. For example, we could perform thresholding on pixel intensity values in the range [0, 255] as we have already seen in the Image Representation in skimage section.</p>
<p>We can now apply the binary_mask to the original coloured image as we learned in the Drawing and Bitwise Operations section. What we are left with is only the coloured shapes from the original.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co"># use the binary_mask to select the "interesting" part of the image</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>selection <span class="op">=</span> image.copy()</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>selection[<span class="op">~</span>binary_mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(selection)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd99cffa0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-77-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Suppose we want to use simple thresholding to select only the coloured shapes (in this particular case we consider grayish to be a colour, too) from the image data/shapes-02.jpg:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> glob</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.filters</span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a><span class="co"># load the image</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/shapes-02.jpg"</span>)</span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd9a56770&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-78-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert the image to grayscale</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="co"># blur the image to denoise</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>plt.imshow(blurred_image, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd9b598a0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-79-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a histogram of the blurred grayscale image</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(blurred_image, bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)</span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Grayscale Histogram"</span>)</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"grayscale value"</span>)</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixels"</span>)</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>(0.0, 1.0)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-80-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We can see a large spike around 0.3, and a smaller spike around 0.7. The spike near 0.3 represents the darker background, so it seems like a value close to t=0.5 would be a good choice.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note that unlike the image with a white background we used above, here the peak for the background colour is at a lower gray level than the shapes. Therefore, change the comparison operator less &lt; to greater &gt; to create the appropriate mask. Then apply the mask to the image and view the thresholded image. If everything works as it should, our output should show only the coloured shapes on a black background.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a mask based on the threshold</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>binary_mask <span class="op">=</span> blurred_image <span class="op">&gt;</span> t</span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(binary_mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd9845300&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-81-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>And here are the commands to apply the mask and view the thresholded image:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/shapes-02.jpg"</span>)</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>selection <span class="op">=</span> image.copy()</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>selection[<span class="op">~</span>binary_mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(selection)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd971ad40&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-82-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="automatic-thresholding" class="level3">
<h3 class="anchored" data-anchor-id="automatic-thresholding">Automatic thresholding</h3>
<p>The downside of the simple thresholding technique is that we have to make an educated guess about the threshold t by inspecting the histogram. There are also <em>automatic thresholding</em> methods that can determine the threshold automatically for us. One such method is **<a href="https://en.wikipedia.org/wiki/Otsu%27s_method">Otsu’s method</a>. It is particularly useful for situations where the grayscale histogram of an image has two peaks that correspond to background and objects of interest.</p>
</section>
<section id="denoising-an-image-before-thresholding" class="level3">
<h3 class="anchored" data-anchor-id="denoising-an-image-before-thresholding">Denoising an image before thresholding</h3>
<p>In practice, it is often necessary to denoise the image before thresholding, which can be done with one of the methods from the <em>Blurring Images</em> section. Consider the image <em>data/maize-root-cluster.jpg</em> of a maize root system which we saw before in the <em>Image Representation in skimage</em> section:</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/maize_cluster.jpg"</span>)</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(image)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fda4de470&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-83-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>We use Gaussian blur with a sigma of 1.0 to denoise the root image. Let us look at the grayscale histogram of the denoised image:</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert the image to grayscale</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a><span class="co"># blur the image to denoise</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a><span class="co"># show the histogram of the blurred image</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(blurred_image, bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)</span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Graylevel histogram"</span>)</span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"gray value"</span>)</span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixel count"</span>)</span>
<span id="cb154-14"><a href="#cb154-14" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>(0.0, 1.0)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-84-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The histogram has a significant peak around 0.2, and a second, smaller peak very near 1.0. Thus, this image is a good candidate for thresholding with Otsu’s method. The mathematical details of how this works are complicated (see the <a href="https://scikit-image.org/docs/dev/api/skimage.filters.html#threshold-otsu">skimage documentation</a> if you are interested), but the outcome is that Otsu’s method finds a threshold value <strong>between</strong> the two peaks of a grayscale histogram.</p>
<p>The <strong>skimage.filters.threshold_otsu()</strong> function can be used to determine the threshold automatically via Otsu’s method. Then numpy comparison operators can be used to apply it as before. Here are the Python commands to determine the threshold t with Otsu’s method:</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="co"># perform automatic thresholding</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> skimage.filters.threshold_otsu(blurred_image)</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found automatic threshold t = </span><span class="sc">{}</span><span class="st">."</span>.<span class="bu">format</span>(t))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found automatic threshold t = 0.43393258215217667.</code></pre>
</div>
</div>
<p>For this root image and a Gaussian blur with the chosen sigma of 1.0, the computed threshold value is 0.43. No we can create a binary mask with the comparison operator &gt;. As we have seen before, pixels above the threshold value will be turned on, those below the threshold will be turned off.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a binary mask with the threshold found by Otsu's method</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>binary_mask <span class="op">=</span> blurred_image <span class="op">&gt;</span> t</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(binary_mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd9b58cd0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-86-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Finally, we use the mask to select the foreground:</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="co"># apply the binary mask to select the foreground</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>selection <span class="op">=</span> image.copy()</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>selection[<span class="op">~</span>binary_mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(selection)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fcfa9b550&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-87-output-2.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="application-measuring-root-mass" class="level3">
<h3 class="anchored" data-anchor-id="application-measuring-root-mass">Application: measuring root mass</h3>
<p>Let us now turn to an application where we can apply thresholding and other techniques we have learned to this point. Consider these four maize root system images, which we can find in the files <em>data/trial-016.jpg</em>, <em>data/trial-020.jpg</em>, <em>data/trial-216.jpg</em>, and <em>data/trial-293.jpg</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/632f8ebb-49f8-4b1d-9e6a-446e365690b0-1-33ad2d8f-4377-4945-85b8-d072ba9e812b.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">four-maize-roots.jpg</figcaption>
</figure>
</div>
<p>Suppose we are interested in the amount of plant material in each image, and in particular how that amount changes from image to image. Perhaps the images represent the growth of the plant over time, or perhaps the images show four different maize varieties at the same phase of their growth. The question we would like to answer is, “how much root mass is in each image?”</p>
<p>We will first construct a Python program to measure this value for a single image. Our strategy will be this:</p>
<ol type="1">
<li>Read the image, converting it to grayscale as it is read. For this application we do not need the colour image.</li>
<li>Blur the image.</li>
<li>Use Otsu’s method of thresholding to create a binary image, where the pixels that were part of the maize plant are white, and everything else is black.</li>
<li>Save the binary image so it can be examined later.</li>
<li>Count the white pixels in the binary image, and divide by the number of pixels in the image. This ratio will be a measure of the root mass of the plant in the image.</li>
<li>Output the name of the image processed and the root mass ratio.</li>
</ol>
<p>Our intent is to perform these steps and produce the numeric result - a measure of the root mass in the image - without human intervention. Implementing the steps within a Python function will enable us to call this function for different images.</p>
<p>Here is a Python function that implements this root-mass-measuring strategy. Since the function is intended to produce numeric output without human interaction, it does not display any of the images. Almost all of the commands should be familiar, and in fact, it may seem simpler than the code we have worked on thus far, because we are not displaying any of the images.</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_root_mass(filename, sigma<span class="op">=</span><span class="fl">1.0</span>):</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># read the original image, converting to grayscale on the fly</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> iio.imread(uri<span class="op">=</span>filename, mode<span class="op">=</span><span class="st">"L"</span>)</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># blur before thresholding</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    blurred_image <span class="op">=</span> skimage.filters.gaussian(image, sigma<span class="op">=</span>sigma)</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># perform automatic thresholding to produce a binary image</span></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> skimage.filters.threshold_otsu(blurred_image)</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>    binary_mask <span class="op">=</span> blurred_image <span class="op">&gt;</span> t</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine root mass ratio</span></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>    rootPixels <span class="op">=</span> np.count_nonzero(binary_mask)</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> binary_mask.shape[<span class="dv">1</span>]</span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> binary_mask.shape[<span class="dv">0</span>]</span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a>    density <span class="op">=</span> rootPixels <span class="op">/</span> (w <span class="op">*</span> h)</span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-19"><a href="#cb162-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> density</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function begins with reading the original image from the file filename. We use <strong>iio.imread()</strong> with the optional argument <strong>mode=“L”</strong> to automatically convert it to grayscale. Next, the grayscale image is blurred with a Gaussian filter with the value of sigma that is passed to the function. Then we determine the threshold t with Otsu’s method and create a binary mask just as we did in the previous section. Up to this point, everything should be familiar.</p>
<p>The final part of the function determines the root mass ratio in the image. Recall that in the <strong>binary_mask</strong>, every pixel has either a value of zero (black/background) or one (white/foreground). We want to count the number of white pixels, which can be accomplished with a call to the numpy function <strong><em>np.count_nonzero</em></strong>. Then we determine the width and height of the image by using the elements of <strong><em>binary_mask.shape</em></strong> (that is, the dimensions of the numpy array that stores the image). Finally, the density ratio is calculated by dividing the number of white pixels by the total number of pixels <em>w</em>h* in the image. The function returns then root density of the image.</p>
<p>We can call this function with any filename and provide a sigma value for the blurring. If no sigma value is provided, the default value 1.0 will be used. For example, for the file <em>data/trial-016.jpg</em> and a sigma value of 1.5, we would call the function like this:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>measure_root_mass(filename<span class="op">=</span><span class="st">"Images/trial-016.jpg"</span>, sigma<span class="op">=</span><span class="fl">1.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>0.04907413563829787</code></pre>
</div>
</div>
<p>Now we can use the function to process the series of four images shown above. In a real-world scientific situation, there might be dozens, hundreds, or even thousands of images to process. To save us the tedium of calling the function for each image by hand, we can write a loop that processes all files automatically. The following code block assumes that the files are located in the same directory and the filenames all start with the <strong>trial-</strong> prefix and end with the <strong>.jpg</strong> suffix.</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>all_files <span class="op">=</span> glob.glob(<span class="st">"Images/trial-*.jpg"</span>)</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> filename <span class="kw">in</span> all_files:</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    density <span class="op">=</span> measure_root_mass(filename<span class="op">=</span>filename, sigma<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># output in format suitable for .csv</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(filename, density, sep<span class="op">=</span><span class="st">","</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Images/trial-216.jpg,0.1420516954787234
Images/trial-016.jpg,0.04907413563829787
Images/trial-293.jpg,0.13665458776595746
Images/trial-020.jpg,0.06381349734042553</code></pre>
</div>
</div>
</section>
<section id="ignoring-more-of-the-images" class="level3">
<h3 class="anchored" data-anchor-id="ignoring-more-of-the-images">Ignoring more of the images</h3>
<p>Let us take a closer look at the binary masks produced by the measure_root_mass function:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/8326da92-5b86-4bc5-929b-a0a8d473d811-1-24d355e4-2c1d-478f-849f-b7b0e0fbecd6.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">four-maize-roots-binary.jpg</figcaption>
</figure>
</div>
<p>You may have noticed in the section on automatic thresholding that the thresholded image does include regions of the image aside of the plant root: the numbered labels and the white circles in each image are preserved during the thresholding, because their grayscale values are above the threshold. Therefore, our calculated root mass ratios include the white pixels of the label and white circle that are not part of the plant root. Those extra pixels affect how accurate the root mass calculation is!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-28-contents" aria-controls="callout-28" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
How might we remove the labels and circles before calculating the ratio, so that our results are more accurate? Think about some options given what we have learned so far.
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-28" class="callout-28-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>One approach we might take is to try to <strong>completely</strong> mask out a region from each image, particularly, the area containing the white circle and the numbered label. If we had coordinates for a rectangular area on the image that contained the circle and the label, we could mask the area out easily by using techniques we learned in the <em>Drawing and Bitwise Operations</em> section.</p>
<p>However, a closer inspection of the binary images raises some issues with that approach. Since the roots are not always constrained to a certain area in the image, and since the circles and labels are in different locations each time, we would have difficulties coming up with a single rectangle that would work for every image. We could create a different masking rectangle for each image, but that is not a practicable approach if we have hundreds or thousands of images to process.</p>
<p>Another approach we could take is to apply two thresholding steps to the image. Look at the graylevel histogram of the file <em>data/trial-016.jpg</em> shown above again. Notice the peak near 1.0? Recall that a grayscale value of 1.0 corresponds to white pixels: the peak corresponds to the white label and circle. So, we could use simple binary thresholding to mask the white circle and label from the image, and then we could use Otsu’s method to select the pixels in the plant portion of the image.</p>
<p>Note that most of this extra work in processing the image could have been avoided during the experimental design stage, with some careful consideration of how the resulting images would be used. For example, all of the following measures could have made the images easier to process, by helping us predict and/or detect where the label is in the image and subsequently mask it from further processing:</p>
<ul>
<li>using labels with a consistent size and shape</li>
<li>placing all the labels in the same position, relative to the sample</li>
<li>using a non-white label, with non-black writing</li>
</ul>
</div>
</div>
</div>
<p>Let’s now Implement an enhanced version of the function <strong>measure_root_mass</strong> that applies simple binary thresholding to remove the white circle and label from the image before applying Otsu’s method. We can apply a simple binary thresholding with a threshold t=0.95 to remove the label and circle from the image. We use the binary mask to set the pixels in the blurred image to zero (black):</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enhanced_root_mass(filename, sigma):</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># read the original image, converting to grayscale on the fly</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> iio.imread(uri<span class="op">=</span>filename, mode<span class="op">=</span><span class="st">"L"</span>)</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># blur before thresholding</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    blurred_image <span class="op">=</span> skimage.filters.gaussian(image, sigma<span class="op">=</span>sigma)</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># perform binary thresholding to mask the white label and circle</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>    binary_mask <span class="op">=</span> blurred_image <span class="op">&lt;</span> <span class="fl">0.95</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># use the mask to remove the circle and label from the blurred image</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>    blurred_image[<span class="op">~</span>binary_mask] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># perform automatic thresholding to produce a binary image</span></span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> skimage.filters.threshold_otsu(blurred_image)</span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a>    binary_mask <span class="op">=</span> blurred_image <span class="op">&gt;</span> t</span>
<span id="cb167-17"><a href="#cb167-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-18"><a href="#cb167-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># determine root mass ratio</span></span>
<span id="cb167-19"><a href="#cb167-19" aria-hidden="true" tabindex="-1"></a>    rootPixels <span class="op">=</span> np.count_nonzero(binary_mask)</span>
<span id="cb167-20"><a href="#cb167-20" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> binary_mask.shape[<span class="dv">1</span>]</span>
<span id="cb167-21"><a href="#cb167-21" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> binary_mask.shape[<span class="dv">0</span>]</span>
<span id="cb167-22"><a href="#cb167-22" aria-hidden="true" tabindex="-1"></a>    density <span class="op">=</span> rootPixels <span class="op">/</span> (w <span class="op">*</span> h)</span>
<span id="cb167-23"><a href="#cb167-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-24"><a href="#cb167-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> density</span>
<span id="cb167-25"><a href="#cb167-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-26"><a href="#cb167-26" aria-hidden="true" tabindex="-1"></a>all_files <span class="op">=</span> glob.glob(<span class="st">"Images/trial-*.jpg"</span>)</span>
<span id="cb167-27"><a href="#cb167-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> filename <span class="kw">in</span> all_files:</span>
<span id="cb167-28"><a href="#cb167-28" aria-hidden="true" tabindex="-1"></a>    density <span class="op">=</span> enhanced_root_mass(filename<span class="op">=</span>filename, sigma<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb167-29"><a href="#cb167-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># output in format suitable for .csv</span></span>
<span id="cb167-30"><a href="#cb167-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(filename, density, sep<span class="op">=</span><span class="st">","</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Images/trial-216.jpg,0.13761419547872342
Images/trial-016.jpg,0.04632878989361702
Images/trial-293.jpg,0.1323479055851064
Images/trial-020.jpg,0.05924468085106383</code></pre>
</div>
</div>
<p>The output of the improved program does illustrate that the white circles and labels were skewing our root mass ratios. The values generated by the enhanced function are lower.</p>
<p>Here are the binary images produced by the additional thresholding. Note that we have not completely removed the offending white pixels. Outlines still remain. However, we have reduced the number of extraneous pixels, which should make the output more accurate.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/db11ca96-0734-4f99-bc8a-0bc1dbc70915-1-9ab4f8fe-7011-4806-9c7a-d5768f2fbf8d.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">four-maize-roots-binary-improved.jpg</figcaption>
</figure>
</div>
</section>
<section id="thresholding-a-bacteria-colony-image" class="level3">
<h3 class="anchored" data-anchor-id="thresholding-a-bacteria-colony-image">Thresholding a bacteria colony image</h3>
<p>In the images directory Images/, you will find an image named colonies-01.tif:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/45647652-b822-452e-a28c-82ca220484bb-1-9febf3ed-8dee-4fbc-bce5-22dc5e8b9e7c.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">colonies-01.jpg</figcaption>
</figure>
</div>
<p>This is one of the images we will be working with in the morphometric challenge at the end of this blog. Let’s first plot and inspect the grayscale histogram of the image to determine a good threshold value for the image:</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> iio.imread(uri<span class="op">=</span><span class="st">"Images/colonies-01.tif"</span>)</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>histogram, bin_edges <span class="op">=</span> np.histogram(blurred_image, bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>plt.plot(bin_edges[<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], histogram)</span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Graylevel histogram"</span>)</span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"gray value"</span>)</span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"pixel count"</span>)</span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="fl">1.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>(0.0, 1.0)</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-92-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The peak near one corresponds to the white image background, and the broader peak around 0.5 corresponds to the yellow/brown culture medium in the dish. The small peak near zero is what we are after: the dark bacteria colonies. A reasonable choice thus might be to leave pixels below t=0.2 on.</p>
<p>Now let’s create the binary mask that leaves the pixels in the bacteria colonies “on” while turning the rest of the pixels in the image “off”. Here is the code to create and show the binarized image using the &lt; operator with a threshold t=0.2:</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>binary_mask <span class="op">=</span> blurred_image <span class="op">&lt;</span> t</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(binary_mask, cmap<span class="op">=</span><span class="st">"gray"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>&lt;matplotlib.image.AxesImage at 0x7f9fd2f0dae0&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-93-output-2.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>thresholding produces a binary image, where all pixels with intensities above (or below) a threshold value are turned on, while all other pixels are turned off</li>
<li>the binary images produced by thresholding are held in two-dimensional NumPy arrays, since they have only one colour value channel. They are boolean, hence they contain the values 0 (off) and 1 (on)</li>
<li>thresholding can be used to create masks that select only the interesting parts of an image, or as the first step before edge detection or finding contours</li>
</ul>
</div>
</div>
</section>
</section>
<section id="connected-component-analysis" class="level2">
<h2 class="anchored" data-anchor-id="connected-component-analysis">7. Connected Component Analysis</h2>
<p>In the <em>Thresholding</em> section we covered dividing an image into foreground and background pixels. In the shapes example image, we considered the coloured shapes as foreground objects on a white background:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/5dc0257e-481e-4467-9cff-c539f026e902-1-d92647d5-374d-46d8-ba93-a5568f4f1b38.jpg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">shapes-01.jpg</figcaption>
</figure>
</div>
<p>In thresholding we went from the original image to this version:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/558c041d-600d-4a4f-bb7c-011a5f30ca05-1-75d1743d-5bbc-4d9e-9ecc-80d63eef406e.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">shapes-01-mask.png</figcaption>
</figure>
</div>
<p>Here, we created a mask that only highlights the parts of the image that we find interesting, the objects. All objects have pixel value of True while the background pixels are False.</p>
<p>By looking at the mask image, we can count the objects that are present in the image (7). But how did we actually do that, how did we decide which lump of pixels constitutes a single object?</p>
<section id="pixel-neighborhoods" class="level3">
<h3 class="anchored" data-anchor-id="pixel-neighborhoods">Pixel Neighborhoods</h3>
<p>In order to decide which pixels belong to the same object, one can exploit their neighborhood: pixels that are directly next to each other and belong to the foreground class can be considered to belong to the same object.</p>
<p>Let’s discuss the concept of pixel neighborhoods in more detail. Consider the following mask “image” with 8 rows, and 8 columns. For the purpose of illustration, the digit 0 is used to represent background pixels, and the letter X is used to represent object pixels foreground).</p>
<pre><code>0 0 0 0 0 0 0 0
0 X X 0 0 0 0 0
0 X X 0 0 0 0 0
0 0 0 X X X 0 0
0 0 0 X X X X 0
0 0 0 0 0 0 0 0</code></pre>
<p>The pixels are organised in a rectangular grid. In order to understand pixel neighborhoods we will introduce the concept of “jumps” between pixels. The jumps follow two rules:</p>
<ol type="1">
<li>Only one jump is allowed along the column, or the row. Diagonal jumps are not allowed. So, from a centre pixel, denoted with o, only the pixels indicated with a 1 are reachable</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/5d83e34c-9782-44dd-83b7-213dfc0fd165-1-75bd5dcb-784f-452c-9aed-c86696a80230.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">one_jump.JPG</figcaption>
</figure>
</div>
<p>The pixels on the diagonal (from o) are not reachable with a single jump, which is denoted by the -. The pixels reachable with a single jump form the <strong>1-jump</strong> neighborhood.</p>
<ol start="2" type="1">
<li>In a sequence of jumps, one may only jump in row and column direction once -&gt; they have to be orthogonal. An example of a sequence of orthogonal jumps is shown below. Starting from o the first jump goes along the row to the right. The second jump then goes along the column direction up. After this, the sequence cannot be continued as a jump has already been made in both row and column direction:</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/d4eeee12-f88b-4855-be87-ec235f27c0ab-1-c54127bf-655e-4ffd-9f9d-32ca72060c80.JPG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">two_jump.JPG</figcaption>
</figure>
</div>
<p>All pixels reachable with one, or two jumps form the <strong>2-jump</strong> neighborhood. The grid below illustrates the pixels reachable from the centre pixel o with a single jump, highlighted with a 1, and the pixels reachable with 2 jumps with a 2.</p>
<pre><code>2 1 2
1 o 1
2 1 2</code></pre>
<p>In the 1-jump version, only pixels that have direct neighbors along rows or columns are considered connected. Diagonal connections are not included in the 1-jump neighborhood. With two jumps, however, we only get a single object A because pixels are also considered connected along the diagonals.</p>
<pre><code>0 0 0 0 0 0 0 0
0 A A 0 0 0 0 0
0 A A 0 0 0 0 0
0 0 0 A A A 0 0
0 0 0 A A A A 0
0 0 0 0 0 0 0 0</code></pre>
</section>
<section id="object-counting" class="level3">
<h3 class="anchored" data-anchor-id="object-counting">Object counting</h3>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-30-contents" aria-controls="callout-30" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Consider the mask below. How many objects with 1 orthogonal jump?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-30" class="callout-30-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Five.</p>
</div>
</div>
</div>
<pre><code>0 0 0 0 0 0 0 0
0 X 0 0 0 X X 0
0 0 X 0 0 0 0 0
0 X 0 X X X 0 0
0 X 0 X X 0 0 0
0 0 0 0 0 0 0 0</code></pre>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-31-contents" aria-controls="callout-31" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Consider the mask above. How many objects with 2 orthogonal jump?
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-31" class="callout-31-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Two.</p>
</div>
</div>
</div>
</section>
<section id="jumps-and-neighborhoods" class="level3">
<h3 class="anchored" data-anchor-id="jumps-and-neighborhoods">Jumps and neighborhoods</h3>
<p>We have just introduced how you can reach different neighboring pixels by performing one or more orthogonal jumps. We have used the terms <strong><em>1-jump</em></strong> and <strong><em>2-jump</em></strong> neighborhood. There is also a different way of referring to these neighborhoods: <strong>the 4- and 8-neighborhood</strong>.</p>
<p>With a single jump you can reach <strong>four</strong> pixels from a given starting pixel. Hence, the <em>1-jump</em> neighborhood corresponds to the <em>4-neighborhood</em>. When two orthogonal jumps are allowed, eight pixels can be reached, so the <em>2-jump neighborhood</em> corresponds to the <em>8-neighborhood</em>.</p>
</section>
<section id="connected-component-analysis-1" class="level3">
<h3 class="anchored" data-anchor-id="connected-component-analysis-1">Connected Component Analysis</h3>
<p>In order to find the objects in an image, we want to employ an operation that is called <strong>Connected Component Analysis (CCA)</strong>. This operation takes a binary image as an input. Usually, the False value in this image is associated with background pixels, and the True value indicates foreground, or object pixels. Such an image can be produced, e.g., with thresholding. Given a thresholded image, the connected component analysis produces a new labeled image with integer pixel values. Pixels with the same value, belong to the same object. Skimage provides connected component analysis in the function skimage.measure.label(). Let us add this function to the already familiar steps of thresholding an image. Here we define a reusable Python function connected_components:</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> imageio.v3 <span class="im">as</span> iio</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.color</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.filters</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> skimage.measure</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> connected_components(filename, sigma<span class="op">=</span><span class="fl">1.0</span>, t<span class="op">=</span><span class="fl">0.5</span>, connectivity<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># load the image</span></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> iio.imread(filename)</span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># convert the image to grayscale</span></span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a>    gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># denoise the image with a Gaussian filter</span></span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a>    blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span>sigma)</span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># mask the image according to threshold</span></span>
<span id="cb177-16"><a href="#cb177-16" aria-hidden="true" tabindex="-1"></a>    binary_mask <span class="op">=</span> blurred_image <span class="op">&lt;</span> t</span>
<span id="cb177-17"><a href="#cb177-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># perform connected component analysis</span></span>
<span id="cb177-18"><a href="#cb177-18" aria-hidden="true" tabindex="-1"></a>    labeled_image, count <span class="op">=</span> skimage.measure.label(binary_mask,</span>
<span id="cb177-19"><a href="#cb177-19" aria-hidden="true" tabindex="-1"></a>                                                 connectivity<span class="op">=</span>connectivity, return_num<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb177-20"><a href="#cb177-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> labeled_image, count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note the new import of skimage.measure in order to use the skimage.measure.label function that performs the CCA. The first four lines of code are familiar from the <em>Thresholding</em> section.</p>
<p>Then we call the <strong>skimage.measure.label function</strong>. This function has one positional argument where we pass the <em>binary_mask</em>, i.e., the binary image to work on. With the optional argument connectivity, we specify the neighborhood in units of orthogonal jumps. For example, by setting <em>connectivity=2</em> we will consider the 2-jump neighborhood introduced above. The function returns a <em>labeled_image</em> where each pixel has a unique value corresponding to the object it belongs to. In addition, we pass the optional parameter <em>return_num=True</em> to return the maximum label index as count.</p>
</section>
<section id="optional-parameters-and-return-values" class="level3">
<h3 class="anchored" data-anchor-id="optional-parameters-and-return-values">Optional parameters and return values</h3>
<p>The optional parameter return_num changes the data type that is returned by the function skimage.measure.label. The number of labels is only returned if return_num is True. Otherwise, the function only returns the labeled image. This means that we have to pay attention when assigning the return value to a variable. If we omit the optional parameter return_num or pass return_num=False, we can call the function as:</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb178"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>labeled_image <span class="op">=</span> skimage.measure.label(binary_mask)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we pass return_num=True, the function returns a tuple and we can assign it as:</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>labeled_image, count <span class="op">=</span> skimage.measure.label(binary_mask, return_num<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we used the same assignment as in the first case, the variable labeled_image would become a tuple, in which labeled_image[0] is the image and labeled_image[1] is the number of labels. This could cause confusion if we assume that labeled_image only contains the image and pass it to other functions. If you get an AttributeError: ‘tuple’ object has no attribute ‘shape’ or similar, check if you have assigned the return values consistently with the optional parameters.</p>
<p>We can call the above function connected_components and display the labeled image like so:</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>labeled_image, count <span class="op">=</span> connected_components(filename<span class="op">=</span><span class="st">"Images/shapes-01.jpg"</span>, sigma<span class="op">=</span><span class="fl">2.0</span>, t<span class="op">=</span><span class="fl">0.9</span>, connectivity<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(labeled_image)</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-97-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Color mappings
</div>
</div>
<div class="callout-body-container callout-body">
<p>Here you might get a warning UserWarning: Low image data range; displaying image with stretched contrast. or just see an all black image (Note: this behavior might change in future versions or not occur with a different image viewer).</p>
<p>What went wrong? When we hover over the black image, the pixel values are shown as numbers in the lower corner of the viewer. We an see that some pixels have values different from 0, so they are not actually pure black.</p>
</div>
</div>
<p>Let’s find out more by examining labeled_image. Properties that might be interesting in this context are dtype, the minimum and maximum value. We can print them with the following lines:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"dtype:"</span>, labeled_image.dtype)</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"min:"</span>, np.<span class="bu">min</span>(labeled_image))</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"max:"</span>, np.<span class="bu">max</span>(labeled_image))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>dtype: int32
min: 0
max: 11</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
int64
</div>
</div>
<div class="callout-body-container callout-body">
<p>If the dtype of labeled_image is int64, this means that values in this image range from -2 ** 63 to 2 ** 63 - 1. Those are really big numbers. From this available space we only use the range from 0 to 11. When showing this image in the viewer, it squeezes the complete range into 256 gray values. Therefore, the range of our numbers will not produce any visible change.</p>
</div>
</div>
<p>Fortunately, the skimage library has tools to cope with this situation.</p>
<p>We can use the function <strong>skimage.color.label2rgb()</strong> to convert the colours in the image (recall that we already used the <em>skimage.color.rgb2gray()</em> function to convert to grayscale). With skimage.color.label2rgb(), all objects are coloured according to a list of colours that can be customised. We can use the following commands to convert and show the image:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert the label image to color image</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>colored_label_image <span class="op">=</span> skimage.color.label2rgb(labeled_image, bg_label<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>plt.imshow(colored_label_image)</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-99-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="how-many-objects-are-in-that-image" class="level3">
<h3 class="anchored" data-anchor-id="how-many-objects-are-in-that-image">How many objects are in that image?</h3>
<p>It looks fairly obvious right? Seven. But, let’s practice. Using the function <strong>connected_components</strong>, we can find two ways of printing out the number of objects found in the image. As you might have guessed, the return value count already contains the number of found images. So it can simply be printed with:</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, count, <span class="st">"objects in the image."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 11 objects in the image.</code></pre>
</div>
</div>
<p>But there is also a way to obtain the number of found objects from the labeled image itself. Recall that all pixels that belong to a single object are assigned the same integer value. The connected component algorithm produces consecutive numbers. The background gets the value 0, the first object gets the value 1, the second object the value 2, and so on. This means that by finding the object with the maximum value, we also know how many objects there are in the image. We can thus use the np.max function from Numpy to find the maximum value that equals the number of found objects:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>num_objects <span class="op">=</span> np.<span class="bu">max</span>(labeled_image)</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, num_objects, <span class="st">"objects in the image."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 11 objects in the image.</code></pre>
</div>
</div>
<p>Invoking the function with sigma=2.0, and threshold=0.9, both methods will print <em>Found 11 objects in the image</em>.</p>
<p>You might wonder why the connected component analysis with sigma=2.0, and threshold=0.9 finds 11 objects, whereas we would expect only 7 objects. Where are the four additional objects? With a bit of detective work, we can spot some small objects in the image, for example, near the left border:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Image_Processing_files/figure-html/f29de280-53f6-405c-9fe8-ad03782145c1-1-26696ac3-ad51-4411-845d-e7efdeb7fbb4.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">shapes-01-cca-detail.png</figcaption>
</figure>
</div>
<p>For us it is clear that these small spots are artifacts and not objects we are interested in. But how can we tell the computer? One way to calibrate the algorithm is to adjust the parameters for blurring (sigma) and thresholding (t), but you may have noticed during the above exercise that it is quite hard to find a combination that produces the right output number. In some cases, background noise gets picked up as an object. And with other parameters, some of the foreground objects get broken up or disappear completely. Therefore, we need other criteria to describe desired properties of the objects that are found.</p>
</section>
<section id="morphometrics---describe-object-features-with-numbers" class="level3">
<h3 class="anchored" data-anchor-id="morphometrics---describe-object-features-with-numbers">Morphometrics - Describe object features with numbers</h3>
<p>Morphometrics is concerned with the quantitative analysis of objects and considers properties such as size and shape. For the example of the images with the shapes, our intuition tells us that the objects should be of a certain size or area. So we could use a minimum area as a criterion for when an object should be detected. To apply such a criterion, we need a way to calculate the area of objects found by connected components. Recall how we determined the root mass in the <em>Thresholding</em> section by counting the pixels in the binary mask. But here we want to calculate the area of several objects in the labeled image. The skimage library provides the function <strong>skimage.measure.regionprops</strong> to measure the properties of labeled regions. It returns a list of RegionProperties that describe each connected region in the images. The properties can be accessed using the attributes of the <strong>RegionProperties</strong> data type. Here we will use the properties “area” and “label”. You can explore the skimage documentation to learn about other properties available.</p>
<p>We can get a list of areas of the labeled objects as follows:</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="co"># compute object features and extract object areas</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>object_features <span class="op">=</span> skimage.measure.regionprops(labeled_image)</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>object_areas <span class="op">=</span> [objf[<span class="st">"area"</span>] <span class="cf">for</span> objf <span class="kw">in</span> object_features]</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>object_areas</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>[318542, 1, 523204, 496613, 517331, 143, 256215, 1, 68, 338784, 265755]</code></pre>
</div>
</div>
</section>
<section id="plot-a-histogram-of-the-object-area-distribution" class="level3">
<h3 class="anchored" data-anchor-id="plot-a-histogram-of-the-object-area-distribution">Plot a histogram of the object area distribution</h3>
<p>it is often helpful to inspect the histogram of an object property. For example, we want to look at the distribution of the object areas.</p>
<ol type="1">
<li>Create and examine a histogram of the object areas obtained with skimage.measure.regionprops</li>
<li>What does the histogram tell us about the objects?</li>
</ol>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the histogram</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>plt.hist(object_areas)</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Area (pixels)"</span>)</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Number of objects"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-103-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The histogram shows the number of objects (vertical axis) whose area is within a certain range (horizontal axis). The height of the bars in the histogram indicates the prevalence of objects with a certain area. The whole histogram tells us about the distribution of object sizes in the image. It is often possible to identify gaps between groups of bars (or peaks if we draw the histogram as a continuous curve) that tell us about certain groups in the image.</p>
<p>In this example, we can see that there are four small objects that contain less than 50000 pixels. Then there is a group of four (1+1+2) objects in the range between 200000 and 400000, and three objects with a size around 500000. For our object count, we might want to disregard the small objects as artifacts, i.e, we want to ignore the leftmost bar of the histogram. We could use a threshold of 50000 as the minimum area to count. In fact, the <strong><em>object_areas</em></strong> list already tells us that there are fewer than 200 pixels in these objects. Therefore, it is reasonable to require a minimum area of at least 200 pixels for a detected object. In practice, finding the “right” threshold can be tricky and usually involves an educated guess based on domain knowledge.</p>
</section>
<section id="filter-objects-by-area" class="level3">
<h3 class="anchored" data-anchor-id="filter-objects-by-area">Filter objects by area</h3>
<p>Now we would like to use a minimum area criterion to obtain a more accurate count of the objects in the image.</p>
<ol type="1">
<li>One way to count only objects above a certain area is to first create a list of those objects, and then take the length of that list as the object count. This can be done as follows:</li>
</ol>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>min_area <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>large_objects <span class="op">=</span> []</span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> objf <span class="kw">in</span> object_features:</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> objf[<span class="st">"area"</span>] <span class="op">&gt;</span> min_area:</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>        large_objects.append(objf[<span class="st">"label"</span>])</span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, <span class="bu">len</span>(large_objects), <span class="st">"objects!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 7 objects!</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Another option is to use Numpy arrays to create the list of large objects. We first create an array object_areas containing the object areas, and an array object_labels containing the object labels. The labels of the objects are also returned by skimage.measure.regionprops. We have already seen that we can create boolean arrays using comparison operators. Here we can use object_areas &gt; min_area to produce an array that has the same dimension as object_labels. It can then used to select the labels of objects whose area is greater than min_area by indexing:</li>
</ol>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>object_areas <span class="op">=</span> np.array([objf[<span class="st">"area"</span>] <span class="cf">for</span> objf <span class="kw">in</span> object_features])</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>object_labels <span class="op">=</span> np.array([objf[<span class="st">"label"</span>] <span class="cf">for</span> objf <span class="kw">in</span> object_features])</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>large_objects <span class="op">=</span> object_labels[object_areas <span class="op">&gt;</span> min_area]</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, <span class="bu">len</span>(large_objects), <span class="st">"objects!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 7 objects!</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
NumPy vs for loops and if statements
</div>
</div>
<div class="callout-body-container callout-body">
<p>The advantage of using Numpy arrays is that for loops and if statements in Python can be slow, and in practice the first approach may not be feasible if the image contains a large number of objects. In that case, Numpy array functions turn out to be very useful because they are much faster.</p>
</div>
</div>
<ol start="3" type="1">
<li>In this example, we can also use the <strong>np.count_nonzero</strong> function that we saw earlier together with the &gt; operator to count the objects whose area is above min_area:</li>
</ol>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> np.count_nonzero(object_areas <span class="op">&gt;</span> min_area)</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, n, <span class="st">"objects!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 7 objects!</code></pre>
</div>
</div>
<p>For all three alternatives, the output is the same and gives the expected count of 7 objects.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Using functions from Numpy and other Python packages
</div>
</div>
<div class="callout-body-container callout-body">
<p>Functions from Python packages such as Numpy are often more efficient and require less code to write. It is a good idea to browse the reference pages of <a href="https://numpy.org/doc/stable/reference/">NumPy</a> and <a href="https://scikit-image.org/docs/stable/api/api.html">skimage</a> to look for an availabe function that can solve a given task.</p>
</div>
</div>
</section>
<section id="remove-small-objects" class="level3">
<h3 class="anchored" data-anchor-id="remove-small-objects">Remove small objects</h3>
<p>We might also want to exclude (mask) the small objects when plotting the labeled image. Enhance the <strong>connected_components</strong> function such that it automatically removes objects that are below a certain area that is passed to the function as an optional parameter.</p>
<ol type="1">
<li>To remove the small objects from the labeled image, we change the value of all pixels that belong to the small objects to the background label 0. One way to do this is to loop over all objects and set the pixels that match the label of the object to :</li>
</ol>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb197"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> object_id, objf <span class="kw">in</span> <span class="bu">enumerate</span>(object_features, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> objf[<span class="st">"area"</span>] <span class="op">&lt;</span> min_area:</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>        labeled_image[labeled_image <span class="op">==</span> objf[<span class="st">"label"</span>]] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li>Here NumPy functions can also be used to eliminate for loops and if statements. Like above, we can create an array of the small object labels with the comparison object_areas &lt; min_area. We can use another Numpy function, np.isin, to set the pixels of all small objects to 0. np.isin takes two arrays and returns a boolean array with values True if the entry of the first array is found in the second array, and False otherwise. This array can then be used to index the labeled_image and set the entries that belong to small objects to 0 :</li>
</ol>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb198"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>object_areas <span class="op">=</span> np.array([objf[<span class="st">"area"</span>] <span class="cf">for</span> objf <span class="kw">in</span> object_features])</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>object_labels <span class="op">=</span> np.array([objf[<span class="st">"label"</span>] <span class="cf">for</span> objf <span class="kw">in</span> object_features])</span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>small_objects <span class="op">=</span> object_labels[object_areas <span class="op">&lt;</span> min_area]</span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>labeled_image[np.isin(labeled_image,small_objects)] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="3" type="1">
<li>An even more elegant way to remove small objects from the image is to leverage the <strong><a href="https://scikit-image.org/docs/stable/api/skimage.morphology.html">skimage.morphology</a></strong> module. It provides a function <strong>skimage.morphology.remove_small_objects</strong> that does exactly what we are looking for. It can be applied to a binary image and returns a mask in which all objects smaller than <em>min_area</em> are excluded, i.e, their pixel values are set to False. We can then apply <strong>skimage.measure.label</strong> to the masked image:</li>
</ol>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb199"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>object_mask <span class="op">=</span> skimage.morphology.remove_small_objects(binary_mask,min_area)</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>labeled_image, n <span class="op">=</span> skimage.measure.label(object_mask,</span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>                                         connectivity<span class="op">=</span><span class="dv">2</span>, return_num<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the skimage features, we can implement the enhanced_connected_component as follows:</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb200"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enhanced_connected_components(filename, sigma<span class="op">=</span><span class="fl">1.0</span>, t<span class="op">=</span><span class="fl">0.5</span>, connectivity<span class="op">=</span><span class="dv">2</span>, min_area<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> iio.imread(filename)</span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    gray_image <span class="op">=</span> skimage.color.rgb2gray(image)</span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>    blurred_image <span class="op">=</span> skimage.filters.gaussian(gray_image, sigma<span class="op">=</span>sigma)</span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>    binary_mask <span class="op">=</span> blurred_image <span class="op">&lt;</span> t</span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    object_mask <span class="op">=</span> skimage.morphology.remove_small_objects(binary_mask,min_area)</span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>    labeled_image, count <span class="op">=</span> skimage.measure.label(object_mask,</span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>                                                 connectivity<span class="op">=</span>connectivity, return_num<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> labeled_image, count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now call the function with a chosen min_area and display the resulting labeled image:</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb201"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>labeled_image, count <span class="op">=</span> enhanced_connected_components(filename<span class="op">=</span><span class="st">"Images/shapes-01.jpg"</span>, sigma<span class="op">=</span><span class="fl">2.0</span>, t<span class="op">=</span><span class="fl">0.9</span>,</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>                                                     connectivity<span class="op">=</span><span class="dv">2</span>, min_area<span class="op">=</span>min_area)</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>colored_label_image <span class="op">=</span> skimage.color.label2rgb(labeled_image, bg_label<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(colored_label_image)</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)<span class="op">;</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Found"</span>, count, <span class="st">"objects in the image."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found 7 objects in the image.</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-111-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Note that the small objects are “gone” and we obtain the correct number of 7 objects in the image.</p>
</section>
<section id="colour-objects-by-area" class="level3">
<h3 class="anchored" data-anchor-id="colour-objects-by-area">Colour objects by area</h3>
<p>Finally, we would like to display the image with the objects coloured according to the magnitude of their area. In practice, this can be used with other properties to give visual cues of the object properties.</p>
<p>We already know how to get the areas of the objects from the regionprops. We just need to insert a zero area value for the background (to colour it like a zero size object). The background is also labeled 0 in the labeled_image, so we insert the zero area value in front of the first element of object_areas with np.insert. Then we can create a colored_area_image where we assign each pixel value the area by indexing the object_areas with the label values in labeled_image.</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb203"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>object_areas <span class="op">=</span> np.array([objf[<span class="st">"area"</span>] <span class="cf">for</span> objf <span class="kw">in</span> skimage.measure.regionprops(labeled_image)])</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>object_areas <span class="op">=</span> np.insert(<span class="dv">0</span>,<span class="dv">1</span>,object_areas)</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>colored_area_image <span class="op">=</span> object_areas[labeled_image]</span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>im <span class="op">=</span> plt.imshow(colored_area_image)</span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>cbar <span class="op">=</span> fig.colorbar(im, ax<span class="op">=</span>ax, shrink<span class="op">=</span><span class="fl">0.85</span>)</span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a>cbar.ax.set_title(<span class="st">"Area"</span>)</span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">"off"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Image_Processing_files/figure-html/cell-112-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>You may have noticed that in the solution, we have used the labeled_image to index the array object_areas. This is an example of <a href="https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing">advanced indexing in NumPy</a>. The result is an array of the same shape as the labeled_image whose pixel values are selected from object_areas according to the object label. Hence the objects will be colored by area when the result is displayed. Note that advanced indexing with an integer array works slightly different than the indexing with a Boolean array that we have used for masking. While Boolean array indexing returns only the entries corresponding to the True values of the index, integer array indexing returns an array with the same shape as the index.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Points:
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>we can use skimage.measure.label to find and label connected objects in an image</li>
<li>we can use skimage.measure.regionprops to measure properties of labeled objects</li>
<li>we can use skimage.morphology.remove_small_objects to mask small objects and remove artifacts from an image</li>
<li>we can display the labeled image to view the objects coloured by label</li>
</ul>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>